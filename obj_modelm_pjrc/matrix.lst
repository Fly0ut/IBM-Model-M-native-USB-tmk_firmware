   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.unselect_cols,"ax",@progbits
  13               	unselect_cols:
  14               	.LFB20:
  15               		.file 1 "matrix.c"
   1:matrix.c      **** /*
   2:matrix.c      **** Copyright 2011 Jun Wako <wakojun@gmail.com>
   3:matrix.c      **** 
   4:matrix.c      **** This program is free software: you can redistribute it and/or modify
   5:matrix.c      **** it under the terms of the GNU General Public License as published by
   6:matrix.c      **** the Free Software Foundation, either version 2 of the License, or
   7:matrix.c      **** (at your option) any later version.
   8:matrix.c      **** 
   9:matrix.c      **** This program is distributed in the hope that it will be useful,
  10:matrix.c      **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:matrix.c      **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:matrix.c      **** GNU General Public License for more details.
  13:matrix.c      **** 
  14:matrix.c      **** You should have received a copy of the GNU General Public License
  15:matrix.c      **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:matrix.c      **** */
  17:matrix.c      **** 
  18:matrix.c      **** #include <stdint.h>
  19:matrix.c      **** #include <stdbool.h>
  20:matrix.c      **** #include <avr/io.h>
  21:matrix.c      **** #include <util/delay.h>
  22:matrix.c      **** #include "print.h"
  23:matrix.c      **** #include "debug.h"
  24:matrix.c      **** #include "util.h"
  25:matrix.c      **** #include "matrix.h"
  26:matrix.c      **** 
  27:matrix.c      **** 
  28:matrix.c      **** #ifndef DEBOUNCE
  29:matrix.c      ****        DEBOUNCE 10
  30:matrix.c      **** #endif
  31:matrix.c      **** 
  32:matrix.c      **** static uint8_t debouncing = DEBOUNCE;
  33:matrix.c      **** 
  34:matrix.c      **** // bit array of key state(1:on, 0:off)
  35:matrix.c      **** static matrix_row_t matrix[MATRIX_ROWS];
  36:matrix.c      **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  37:matrix.c      **** 
  38:matrix.c      **** #ifdef MATRIX_HAS_GHOST
  39:matrix.c      **** static bool matrix_has_ghost_in_row(matrix_row_t row);
  40:matrix.c      **** #endif
  41:matrix.c      **** static matrix_row_t read_rows(void);
  42:matrix.c      **** static void init_rows(void);
  43:matrix.c      **** static void unselect_cols(void);
  44:matrix.c      **** static void select_col(matrix_col_t col);
  45:matrix.c      **** 
  46:matrix.c      **** #ifndef SLEEP_LED_ENABLE
  47:matrix.c      **** /* LEDs are on output compare pins OC1B OC1C
  48:matrix.c      ****    This activates fast PWM mode on them.
  49:matrix.c      ****    Prescaler 256 and 8-bit counter results in
  50:matrix.c      ****    16000000/256/256 = 244 Hz blink frequency.
  51:matrix.c      ****    LED_A: Caps Lock
  52:matrix.c      ****    LED_B: Scroll Lock  */
  53:matrix.c      **** /* Output on PWM pins are turned off when the timer
  54:matrix.c      ****    reaches the value in the output compare register,
  55:matrix.c      ****    and are turned on when it reaches TOP (=256). */
  56:matrix.c      **** static
  57:matrix.c      **** void setup_leds(void)
  58:matrix.c      **** {
  59:matrix.c      ****     /*
  60:matrix.c      ****     TCCR1A |=      // Timer control register 1A
  61:matrix.c      ****         (1<<WGM10) | // Fast PWM 8-bit
  62:matrix.c      ****         (1<<COM1B1)| // Clear OC1B on match, set at TOP
  63:matrix.c      ****         (1<<COM1C1); // Clear OC1C on match, set at TOP
  64:matrix.c      ****     TCCR1B |=      // Timer control register 1B
  65:matrix.c      ****         (1<<WGM12) | // Fast PWM 8-bit
  66:matrix.c      ****         (1<<CS12);   // Prescaler 256
  67:matrix.c      ****     OCR1B = LED_BRIGHTNESS;    // Output compare register 1B
  68:matrix.c      ****     OCR1C = LED_BRIGHTNESS;    // Output compare register 1C
  69:matrix.c      ****     // LEDs: LED_A -> PORTB6, LED_B -> PORTB7
  70:matrix.c      ****     DDRB  |= (1<<6) | (1<<7);
  71:matrix.c      ****     PORTB  &= ~((1<<6) | (1<<7));
  72:matrix.c      ****     */
  73:matrix.c      **** }
  74:matrix.c      **** #endif
  75:matrix.c      **** 
  76:matrix.c      **** inline
  77:matrix.c      **** matrix_row_t matrix_rows(void)
  78:matrix.c      **** {
  79:matrix.c      ****     return MATRIX_ROWS;
  80:matrix.c      **** }
  81:matrix.c      **** 
  82:matrix.c      **** inline
  83:matrix.c      **** matrix_col_t matrix_cols(void)
  84:matrix.c      **** {
  85:matrix.c      ****     return MATRIX_COLS;
  86:matrix.c      **** }
  87:matrix.c      **** 
  88:matrix.c      **** void matrix_init(void)
  89:matrix.c      **** {
  90:matrix.c      ****     // To use PORTF disable JTAG with writing JTD bit twice within four cycles.
  91:matrix.c      ****     //MCUCR |= (1<<JTD);
  92:matrix.c      ****     //MCUCR |= (1<<JTD);
  93:matrix.c      **** 
  94:matrix.c      ****     // initialize row and col
  95:matrix.c      ****     unselect_cols();
  96:matrix.c      ****     init_rows();
  97:matrix.c      **** #ifndef SLEEP_LED_ENABLE
  98:matrix.c      ****     setup_leds();
  99:matrix.c      **** #endif
 100:matrix.c      **** 
 101:matrix.c      ****     // initialize matrix state: all keys off
 102:matrix.c      ****     for (matrix_row_t i = 0; i < MATRIX_ROWS; i++)  {
 103:matrix.c      ****         matrix[i] = 0;
 104:matrix.c      ****         matrix_debouncing[i] = 0;
 105:matrix.c      ****     }
 106:matrix.c      **** }
 107:matrix.c      **** 
 108:matrix.c      **** matrix_row_t matrix_scan(void)
 109:matrix.c      **** {
 110:matrix.c      ****     for (matrix_col_t col = 0; col < MATRIX_COLS; col++) {  // 0-7
 111:matrix.c      ****         select_col(col);
 112:matrix.c      ****         _delay_us(30);       // without this wait it won't read stable value.
 113:matrix.c      ****         matrix_row_t rows = read_rows();
 114:matrix.c      **** 
 115:matrix.c      ****         for (matrix_row_t row = 0; row < MATRIX_ROWS; row++) {  // 0-15
 116:matrix.c      ****             bool prev_bit = matrix_debouncing[row] & ((matrix_row_t)1<<col);
 117:matrix.c      ****             bool curr_bit = rows & (1<<row);
 118:matrix.c      ****             if (prev_bit != curr_bit) {
 119:matrix.c      ****                 matrix_debouncing[row] ^= ((matrix_row_t)1<<col);
 120:matrix.c      ****                 if (debouncing) {
 121:matrix.c      ****                     dprint("bounce!: "); dprintf("%02X", debouncing); dprintln();
 122:matrix.c      ****                 }
 123:matrix.c      ****                 debouncing = DEBOUNCE;
 124:matrix.c      ****             }
 125:matrix.c      ****         }
 126:matrix.c      ****         unselect_cols();
 127:matrix.c      ****     }
 128:matrix.c      **** 
 129:matrix.c      ****     if (debouncing) {
 130:matrix.c      ****         if (--debouncing) {
 131:matrix.c      ****             _delay_ms(1);
 132:matrix.c      ****         } else {
 133:matrix.c      ****             for (matrix_row_t i = 0; i < MATRIX_ROWS; i++) {
 134:matrix.c      ****                 matrix[i] = matrix_debouncing[i];
 135:matrix.c      ****             }
 136:matrix.c      ****         }
 137:matrix.c      ****     }
 138:matrix.c      **** 
 139:matrix.c      ****     return 1;
 140:matrix.c      **** }
 141:matrix.c      **** 
 142:matrix.c      **** bool matrix_is_modified(void)
 143:matrix.c      **** {
 144:matrix.c      ****     if (debouncing) return false;
 145:matrix.c      ****     return true;
 146:matrix.c      **** }
 147:matrix.c      **** 
 148:matrix.c      **** inline
 149:matrix.c      **** bool matrix_is_on(matrix_row_t row, matrix_col_t col)
 150:matrix.c      **** {
 151:matrix.c      ****     return (matrix[row] & ((matrix_row_t)1<<col));
 152:matrix.c      **** }
 153:matrix.c      **** 
 154:matrix.c      **** inline
 155:matrix.c      **** matrix_row_t matrix_get_row(matrix_row_t row)
 156:matrix.c      **** {
 157:matrix.c      ****     return matrix[row];
 158:matrix.c      **** }
 159:matrix.c      **** 
 160:matrix.c      **** /*
 161:matrix.c      **** *void matrix_print(void)
 162:matrix.c      **** *{
 163:matrix.c      **** *   print("\nr/c 0123456789ABCDEF\n");
 164:matrix.c      **** *   for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 165:matrix.c      **** *       xprintf("%02X: %032lb\n", row, bitrev32(matrix_get_row(row)));
 166:matrix.c      **** *   }
 167:matrix.c      **** *}
 168:matrix.c      **** */
 169:matrix.c      **** 
 170:matrix.c      **** void matrix_print(void)
 171:matrix.c      **** {
 172:matrix.c      ****     print("\nr/c 01234567\n");
 173:matrix.c      ****     for (matrix_row_t row = 0; row < matrix_rows(); row++) {
 174:matrix.c      ****         phex(row); print(": ");
 175:matrix.c      ****         pbin_reverse(matrix_get_row(row));
 176:matrix.c      **** #ifdef MATRIX_HAS_GHOST
 177:matrix.c      ****         if (matrix_has_ghost_in_row(row)) {
 178:matrix.c      ****             print(" <ghost");
 179:matrix.c      ****         }
 180:matrix.c      **** #endif
 181:matrix.c      ****         print("\n");
 182:matrix.c      ****     }
 183:matrix.c      **** }
 184:matrix.c      **** 
 185:matrix.c      **** #ifdef MATRIX_HAS_GHOST
 186:matrix.c      **** inline
 187:matrix.c      **** static bool matrix_has_ghost_in_row(matrix_row_t row)
 188:matrix.c      **** {
 189:matrix.c      ****     // no ghost exists in case less than 2 keys on
 190:matrix.c      ****     if (((matrix[row] - 1) & matrix[row]) == 0)
 191:matrix.c      ****         return false;
 192:matrix.c      **** 
 193:matrix.c      ****     // ghost exists in case same state as other row
 194:matrix.c      ****     for (matrix_row_t i=0; i < MATRIX_ROWS; i++) {
 195:matrix.c      ****         if (i != row && (matrix[i] & matrix[row]))
 196:matrix.c      ****             return true;
 197:matrix.c      ****     }
 198:matrix.c      ****     return false;
 199:matrix.c      **** }
 200:matrix.c      **** #endif
 201:matrix.c      **** 
 202:matrix.c      **** matrix_row_t matrix_key_count(void)
 203:matrix.c      **** {
 204:matrix.c      ****     matrix_row_t count = 0;
 205:matrix.c      ****     for (matrix_row_t i = 0; i < MATRIX_ROWS; i++) {
 206:matrix.c      ****         count += bitpop32(matrix[i]);
 207:matrix.c      ****     }
 208:matrix.c      ****     return count;
 209:matrix.c      **** }
 210:matrix.c      **** 
 211:matrix.c      **** /* Row pin configuration
 212:matrix.c      ****  * row: 0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15
 213:matrix.c      ****  * pin: C7 C6 C5 C4 C3 C2 C1 C0 E1 E0 D7 D6 D5 D4 D3 D2
 214:matrix.c      ****  */
 215:matrix.c      **** static void init_rows(void) {
 216:matrix.c      ****     // Input with pull-up(DDR:0, PORT:1)
 217:matrix.c      ****     //        0b76543210
 218:matrix.c      ****     DDRC  &= ~0b11111111; //PC: 7 6 5 4 3 2 1 0
 219:matrix.c      ****     PORTC |=  0b11111111; //PC: 7 6 5 4 3 2 1 0
 220:matrix.c      ****     //ToDo: Issues starts on row 8 and rows >=8 don't register.
 221:matrix.c      ****     //left ctl <-> alt, caps lock <-> ctl, back space <-> backslash
 222:matrix.c      ****     //F6, F7, F8, 8, 9, 0, -, + , i, o, p, {, }, k, l, ;, ', ,, ., /, all numpad, nav cluster, arro
 223:matrix.c      ****     DDRE  &= ~(1 << 1 | 1 << 0); //PE: 1 0
 224:matrix.c      ****     PORTE |=  (1 << 1 | 1 << 0); //PE: 1 0
 225:matrix.c      ****     //DDRD  &= ~0b11111000; //PD: 7 6 5 4 3
 226:matrix.c      ****     //PORTD |=  0b11111000; //PD: 7 6 5 4 3
 227:matrix.c      ****     DDRD  &= ~(1 << 7 | 1 << 6 | 1 << 5 | 1 << 4 | 1 << 3 | 1 << 2);
 228:matrix.c      ****     PORTD |=  (1 << 7 | 1 << 6 | 1 << 5 | 1 << 4 | 1 << 3 | 1 << 2);
 229:matrix.c      **** 
 230:matrix.c      **** }
 231:matrix.c      **** static matrix_row_t read_rows(void)
 232:matrix.c      **** {
 233:matrix.c      ****     return (PINC&(1<<7) ? 0 : (1<<0)) |
 234:matrix.c      ****            (PINC&(1<<6) ? 0 : (1<<1)) |
 235:matrix.c      ****            (PINC&(1<<5) ? 0 : (1<<2)) |
 236:matrix.c      ****            (PINC&(1<<4) ? 0 : (1<<3)) |
 237:matrix.c      ****            (PINC&(1<<3) ? 0 : (1<<4)) |
 238:matrix.c      ****            (PINC&(1<<2) ? 0 : (1<<5)) |
 239:matrix.c      ****           //Here is where the inputs stop.
 240:matrix.c      ****            (PINC&(1<<1) ? 0 : (1<<6)) |
 241:matrix.c      ****            (PINC&(1<<0) ? 0 : (1<<7)) |
 242:matrix.c      ****            (PINE&(1<<1) ? 0 : (1<<8)) |
 243:matrix.c      ****            (PINE&(1<<0) ? 0 : (1<<9)) |
 244:matrix.c      ****            (PIND&(1<<7) ? 0 : (1<<10)) |
 245:matrix.c      ****            (PIND&(1<<6) ? 0 : (1<<11)) |
 246:matrix.c      ****            (PIND&(1<<5) ? 0 : (1<<12)) |
 247:matrix.c      ****            (PIND&(1<<4) ? 0 : (1<<13)) |
 248:matrix.c      ****            (PIND&(1<<3) ? 0 : (1<<14)) |
 249:matrix.c      ****            (PIND&(1<<2) ? 0 : (1<<15));
 250:matrix.c      **** }
 251:matrix.c      **** 
 252:matrix.c      **** /* Column pin configuration
 253:matrix.c      ****  * col:  0  1  2  3  4  5  6  7
 254:matrix.c      ****  * pin: B0 E7 E6 F0 F1 F2 F3 F4
 255:matrix.c      ****  */
 256:matrix.c      **** static void unselect_cols(void)
 257:matrix.c      **** {
  16               		.loc 1 257 1 view -0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
 258:matrix.c      ****     //Hi-Z(DDR:0, PORT:0) to unselect
 259:matrix.c      ****     //DDRB &= ~(1<<0);
 260:matrix.c      ****     //PORTB &= ~(1<<0);
 261:matrix.c      ****     //        0b76543210
 262:matrix.c      ****     DDRB  &= ~0b00000001; //PB: 0
  22               		.loc 1 262 5 view .LVU1
  23               		.loc 1 262 11 is_stmt 0 view .LVU2
  24 0000 2098      		cbi 0x4,0
 263:matrix.c      ****     PORTB &= ~0b00000001; //PB: 0
  25               		.loc 1 263 5 is_stmt 1 view .LVU3
  26               		.loc 1 263 11 is_stmt 0 view .LVU4
  27 0002 2898      		cbi 0x5,0
 264:matrix.c      ****     //        0b76543210
 265:matrix.c      ****     DDRF  &= ~0b00011111;  //PF: 4 3 2 1 0
  28               		.loc 1 265 5 is_stmt 1 view .LVU5
  29               		.loc 1 265 11 is_stmt 0 view .LVU6
  30 0004 80B3      		in r24,0x10
  31 0006 807E      		andi r24,lo8(-32)
  32 0008 80BB      		out 0x10,r24
 266:matrix.c      ****     PORTF &= ~0b00011111;  //PF: 4 3 2 1 0
  33               		.loc 1 266 5 is_stmt 1 view .LVU7
  34               		.loc 1 266 11 is_stmt 0 view .LVU8
  35 000a 81B3      		in r24,0x11
  36 000c 807E      		andi r24,lo8(-32)
  37 000e 81BB      		out 0x11,r24
 267:matrix.c      ****     //DDRE  &= ~(1<<7 | 1<<6);  //PE: 7 6
 268:matrix.c      ****     //PORTE &= ~(1<<7 | 1<<6);  //PE: 7 6
 269:matrix.c      ****     //        0b76543210
 270:matrix.c      ****     DDRE  &= ~0b11000000; //PE: 7 6
  38               		.loc 1 270 5 is_stmt 1 view .LVU9
  39               		.loc 1 270 11 is_stmt 0 view .LVU10
  40 0010 8DB1      		in r24,0xd
  41 0012 8F73      		andi r24,lo8(63)
  42 0014 8DB9      		out 0xd,r24
 271:matrix.c      ****     PORTE &= ~0b11000000; //PE: 7 6
  43               		.loc 1 271 5 is_stmt 1 view .LVU11
  44               		.loc 1 271 11 is_stmt 0 view .LVU12
  45 0016 8EB1      		in r24,0xe
  46 0018 8F73      		andi r24,lo8(63)
  47 001a 8EB9      		out 0xe,r24
  48               	/* epilogue start */
 272:matrix.c      **** }
  49               		.loc 1 272 1 view .LVU13
  50 001c 0895      		ret
  51               		.cfi_endproc
  52               	.LFE20:
  54               		.section	.text.matrix_rows,"ax",@progbits
  55               	.global	matrix_rows
  57               	matrix_rows:
  58               	.LFB8:
  78:matrix.c      ****     return MATRIX_ROWS;
  59               		.loc 1 78 1 is_stmt 1 view -0
  60               		.cfi_startproc
  61               	/* prologue: function */
  62               	/* frame size = 0 */
  63               	/* stack size = 0 */
  64               	.L__stack_usage = 0
  79:matrix.c      **** }
  65               		.loc 1 79 5 view .LVU15
  80:matrix.c      **** 
  66               		.loc 1 80 1 is_stmt 0 view .LVU16
  67 0000 80E1      		ldi r24,lo8(16)
  68 0002 90E0      		ldi r25,0
  69               	/* epilogue start */
  70 0004 0895      		ret
  71               		.cfi_endproc
  72               	.LFE8:
  74               		.section	.text.matrix_cols,"ax",@progbits
  75               	.global	matrix_cols
  77               	matrix_cols:
  78               	.LFB9:
  84:matrix.c      ****     return MATRIX_COLS;
  79               		.loc 1 84 1 is_stmt 1 view -0
  80               		.cfi_startproc
  81               	/* prologue: function */
  82               	/* frame size = 0 */
  83               	/* stack size = 0 */
  84               	.L__stack_usage = 0
  85:matrix.c      **** }
  85               		.loc 1 85 5 view .LVU18
  86:matrix.c      **** 
  86               		.loc 1 86 1 is_stmt 0 view .LVU19
  87 0000 88E0      		ldi r24,lo8(8)
  88               	/* epilogue start */
  89 0002 0895      		ret
  90               		.cfi_endproc
  91               	.LFE9:
  93               		.section	.text.matrix_init,"ax",@progbits
  94               	.global	matrix_init
  96               	matrix_init:
  97               	.LFB10:
  89:matrix.c      ****     // To use PORTF disable JTAG with writing JTD bit twice within four cycles.
  98               		.loc 1 89 1 is_stmt 1 view -0
  99               		.cfi_startproc
 100               	/* prologue: function */
 101               	/* frame size = 0 */
 102               	/* stack size = 0 */
 103               	.L__stack_usage = 0
  95:matrix.c      ****     init_rows();
 104               		.loc 1 95 5 view .LVU21
 105 0000 0E94 0000 		call unselect_cols
 106               	.LVL0:
  96:matrix.c      **** #ifndef SLEEP_LED_ENABLE
 107               		.loc 1 96 5 view .LVU22
 108               	.LBB28:
 109               	.LBI28:
 215:matrix.c      ****     // Input with pull-up(DDR:0, PORT:1)
 110               		.loc 1 215 13 view .LVU23
 111               	.LBB29:
 218:matrix.c      ****     PORTC |=  0b11111111; //PC: 7 6 5 4 3 2 1 0
 112               		.loc 1 218 5 view .LVU24
 218:matrix.c      ****     PORTC |=  0b11111111; //PC: 7 6 5 4 3 2 1 0
 113               		.loc 1 218 11 is_stmt 0 view .LVU25
 114 0004 87B1      		in r24,0x7
 115 0006 17B8      		out 0x7,__zero_reg__
 219:matrix.c      ****     //ToDo: Issues starts on row 8 and rows >=8 don't register.
 116               		.loc 1 219 5 is_stmt 1 view .LVU26
 219:matrix.c      ****     //ToDo: Issues starts on row 8 and rows >=8 don't register.
 117               		.loc 1 219 11 is_stmt 0 view .LVU27
 118 0008 88B1      		in r24,0x8
 119 000a 8FEF      		ldi r24,lo8(-1)
 120 000c 88B9      		out 0x8,r24
 223:matrix.c      ****     PORTE |=  (1 << 1 | 1 << 0); //PE: 1 0
 121               		.loc 1 223 5 is_stmt 1 view .LVU28
 223:matrix.c      ****     PORTE |=  (1 << 1 | 1 << 0); //PE: 1 0
 122               		.loc 1 223 11 is_stmt 0 view .LVU29
 123 000e 8DB1      		in r24,0xd
 124 0010 8C7F      		andi r24,lo8(-4)
 125 0012 8DB9      		out 0xd,r24
 224:matrix.c      ****     //DDRD  &= ~0b11111000; //PD: 7 6 5 4 3
 126               		.loc 1 224 5 is_stmt 1 view .LVU30
 224:matrix.c      ****     //DDRD  &= ~0b11111000; //PD: 7 6 5 4 3
 127               		.loc 1 224 11 is_stmt 0 view .LVU31
 128 0014 8EB1      		in r24,0xe
 129 0016 8360      		ori r24,lo8(3)
 130 0018 8EB9      		out 0xe,r24
 227:matrix.c      ****     PORTD |=  (1 << 7 | 1 << 6 | 1 << 5 | 1 << 4 | 1 << 3 | 1 << 2);
 131               		.loc 1 227 5 is_stmt 1 view .LVU32
 227:matrix.c      ****     PORTD |=  (1 << 7 | 1 << 6 | 1 << 5 | 1 << 4 | 1 << 3 | 1 << 2);
 132               		.loc 1 227 11 is_stmt 0 view .LVU33
 133 001a 8AB1      		in r24,0xa
 134 001c 8370      		andi r24,lo8(3)
 135 001e 8AB9      		out 0xa,r24
 228:matrix.c      **** 
 136               		.loc 1 228 5 is_stmt 1 view .LVU34
 228:matrix.c      **** 
 137               		.loc 1 228 11 is_stmt 0 view .LVU35
 138 0020 8BB1      		in r24,0xb
 139 0022 8C6F      		ori r24,lo8(-4)
 140 0024 8BB9      		out 0xb,r24
 141               	.LVL1:
 228:matrix.c      **** 
 142               		.loc 1 228 11 view .LVU36
 143               	.LBE29:
 144               	.LBE28:
 145               	.LBB30:
 102:matrix.c      ****         matrix[i] = 0;
 146               		.loc 1 102 32 is_stmt 1 view .LVU37
 103:matrix.c      ****         matrix_debouncing[i] = 0;
 147               		.loc 1 103 19 is_stmt 0 view .LVU38
 148 0026 80E2      		ldi r24,lo8(32)
 149 0028 E0E0      		ldi r30,lo8(matrix)
 150 002a F0E0      		ldi r31,hi8(matrix)
 151 002c DF01      		movw r26,r30
 152 002e 982F      		mov r25,r24
 153               		0:
 154 0030 1D92      		st X+,__zero_reg__
 155 0032 9A95      		dec r25
 156 0034 01F4      		brne 0b
 104:matrix.c      ****     }
 157               		.loc 1 104 30 view .LVU39
 158 0036 E0E0      		ldi r30,lo8(matrix_debouncing)
 159 0038 F0E0      		ldi r31,hi8(matrix_debouncing)
 160 003a DF01      		movw r26,r30
 161               		0:
 162 003c 1D92      		st X+,__zero_reg__
 163 003e 8A95      		dec r24
 164 0040 01F4      		brne 0b
 165               	.LVL2:
 166               	/* epilogue start */
 104:matrix.c      ****     }
 167               		.loc 1 104 30 view .LVU40
 168               	.LBE30:
 106:matrix.c      **** 
 169               		.loc 1 106 1 view .LVU41
 170 0042 0895      		ret
 171               		.cfi_endproc
 172               	.LFE10:
 174               		.section	.text.matrix_scan,"ax",@progbits
 175               	.global	matrix_scan
 177               	matrix_scan:
 178               	.LFB11:
 109:matrix.c      ****     for (matrix_col_t col = 0; col < MATRIX_COLS; col++) {  // 0-7
 179               		.loc 1 109 1 is_stmt 1 view -0
 180               		.cfi_startproc
 181 0000 2F92      		push r2
 182               	.LCFI0:
 183               		.cfi_def_cfa_offset 3
 184               		.cfi_offset 2, -2
 185 0002 3F92      		push r3
 186               	.LCFI1:
 187               		.cfi_def_cfa_offset 4
 188               		.cfi_offset 3, -3
 189 0004 4F92      		push r4
 190               	.LCFI2:
 191               		.cfi_def_cfa_offset 5
 192               		.cfi_offset 4, -4
 193 0006 5F92      		push r5
 194               	.LCFI3:
 195               		.cfi_def_cfa_offset 6
 196               		.cfi_offset 5, -5
 197 0008 6F92      		push r6
 198               	.LCFI4:
 199               		.cfi_def_cfa_offset 7
 200               		.cfi_offset 6, -6
 201 000a 7F92      		push r7
 202               	.LCFI5:
 203               		.cfi_def_cfa_offset 8
 204               		.cfi_offset 7, -7
 205 000c 8F92      		push r8
 206               	.LCFI6:
 207               		.cfi_def_cfa_offset 9
 208               		.cfi_offset 8, -8
 209 000e 9F92      		push r9
 210               	.LCFI7:
 211               		.cfi_def_cfa_offset 10
 212               		.cfi_offset 9, -9
 213 0010 AF92      		push r10
 214               	.LCFI8:
 215               		.cfi_def_cfa_offset 11
 216               		.cfi_offset 10, -10
 217 0012 BF92      		push r11
 218               	.LCFI9:
 219               		.cfi_def_cfa_offset 12
 220               		.cfi_offset 11, -11
 221 0014 CF92      		push r12
 222               	.LCFI10:
 223               		.cfi_def_cfa_offset 13
 224               		.cfi_offset 12, -12
 225 0016 DF92      		push r13
 226               	.LCFI11:
 227               		.cfi_def_cfa_offset 14
 228               		.cfi_offset 13, -13
 229 0018 EF92      		push r14
 230               	.LCFI12:
 231               		.cfi_def_cfa_offset 15
 232               		.cfi_offset 14, -14
 233 001a FF92      		push r15
 234               	.LCFI13:
 235               		.cfi_def_cfa_offset 16
 236               		.cfi_offset 15, -15
 237 001c 0F93      		push r16
 238               	.LCFI14:
 239               		.cfi_def_cfa_offset 17
 240               		.cfi_offset 16, -16
 241 001e 1F93      		push r17
 242               	.LCFI15:
 243               		.cfi_def_cfa_offset 18
 244               		.cfi_offset 17, -17
 245 0020 CF93      		push r28
 246               	.LCFI16:
 247               		.cfi_def_cfa_offset 19
 248               		.cfi_offset 28, -18
 249 0022 DF93      		push r29
 250               	.LCFI17:
 251               		.cfi_def_cfa_offset 20
 252               		.cfi_offset 29, -19
 253 0024 CDB7      		in r28,__SP_L__
 254 0026 DEB7      		in r29,__SP_H__
 255               	.LCFI18:
 256               		.cfi_def_cfa_register 28
 257 0028 6997      		sbiw r28,25
 258               	.LCFI19:
 259               		.cfi_def_cfa_offset 45
 260 002a 0FB6      		in __tmp_reg__,__SREG__
 261 002c F894      		cli
 262 002e DEBF      		out __SP_H__,r29
 263 0030 0FBE      		out __SREG__,__tmp_reg__
 264 0032 CDBF      		out __SP_L__,r28
 265               	/* prologue: function */
 266               	/* frame size = 25 */
 267               	/* stack size = 43 */
 268               	.L__stack_usage = 43
 110:matrix.c      ****         select_col(col);
 269               		.loc 1 110 5 view .LVU43
 270               	.LBB47:
 110:matrix.c      ****         select_col(col);
 271               		.loc 1 110 10 view .LVU44
 272               	.LVL3:
 110:matrix.c      ****         select_col(col);
 273               		.loc 1 110 36 view .LVU45
 274               	.LBE47:
 109:matrix.c      ****     for (matrix_col_t col = 0; col < MATRIX_COLS; col++) {  // 0-7
 275               		.loc 1 109 1 is_stmt 0 view .LVU46
 276 0034 B12C      		mov r11,__zero_reg__
 277 0036 A12C      		mov r10,__zero_reg__
 278               	.LBB66:
 279               	.LBB48:
 280               	.LBB49:
 281               	.LBB50:
 116:matrix.c      ****             bool curr_bit = rows & (1<<row);
 282               		.loc 1 116 70 view .LVU47
 283 0038 4424      		clr r4
 284 003a 4394      		inc r4
 285 003c 512C      		mov r5,__zero_reg__
 286               	.LVL4:
 287               	.L22:
 116:matrix.c      ****             bool curr_bit = rows & (1<<row);
 288               		.loc 1 116 70 view .LVU48
 289               	.LBE50:
 290               	.LBE49:
 111:matrix.c      ****         _delay_us(30);       // without this wait it won't read stable value.
 291               		.loc 1 111 9 is_stmt 1 view .LVU49
 292               	.LBB56:
 293               	.LBI56:
 273:matrix.c      **** 
 274:matrix.c      **** static void select_col(matrix_col_t col)
 294               		.loc 1 274 13 view .LVU50
 295               	.LBB57:
 275:matrix.c      **** {
 276:matrix.c      ****     switch(col)
 296               		.loc 1 276 5 view .LVU51
 297 003e EFEF      		ldi r30,lo8(-1)
 298 0040 EA0D      		add r30,r10
 299 0042 E730      		cpi r30,lo8(7)
 300 0044 00F4      		brsh .L6
 301 0046 F0E0      		ldi r31,0
 302 0048 E050      		subi r30,lo8(-(gs(.L8)))
 303 004a F040      		sbci r31,hi8(-(gs(.L8)))
 304 004c 0C94 0000 		jmp __tablejump2__
 305               		.section	.jumptables.gcc.matrix_scan,"a",@progbits
 306               		.p2align	1
 307               	.L8:
 308 0000 0000      		.word gs(.L14)
 309 0002 0000      		.word gs(.L13)
 310 0004 0000      		.word gs(.L12)
 311 0006 0000      		.word gs(.L11)
 312 0008 0000      		.word gs(.L10)
 313 000a 0000      		.word gs(.L9)
 314 000c 0000      		.word gs(.L7)
 315               		.section	.text.matrix_scan
 316               	.L6:
 277:matrix.c      ****     {
 278:matrix.c      ****         case 0:
 279:matrix.c      ****             DDRB  |=  (1<<0);
 317               		.loc 1 279 13 view .LVU52
 318               		.loc 1 279 19 is_stmt 0 view .LVU53
 319 0050 209A      		sbi 0x4,0
 280:matrix.c      ****             PORTB &= ~(1<<0);
 320               		.loc 1 280 13 is_stmt 1 view .LVU54
 321               		.loc 1 280 19 is_stmt 0 view .LVU55
 322 0052 2898      		cbi 0x5,0
 281:matrix.c      ****             break;
 323               		.loc 1 281 13 is_stmt 1 view .LVU56
 324               	.LVL5:
 325               	.L15:
 326               		.loc 1 281 13 is_stmt 0 view .LVU57
 327               	.LBE57:
 328               	.LBE56:
 112:matrix.c      ****         matrix_row_t rows = read_rows();
 329               		.loc 1 112 9 is_stmt 1 view .LVU58
 330               	.LBB59:
 331               	.LBI59:
 332               		.file 2 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/avr/include/util/delay.h **** 
 189:/usr/avr/include/util/delay.h **** #else
 190:/usr/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/avr/include/util/delay.h **** 	{
 196:/usr/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/avr/include/util/delay.h **** 		{
 200:/usr/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/avr/include/util/delay.h **** 		}
 204:/usr/avr/include/util/delay.h **** 		return;
 205:/usr/avr/include/util/delay.h **** 	}
 206:/usr/avr/include/util/delay.h **** 	else
 207:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/avr/include/util/delay.h **** #endif
 210:/usr/avr/include/util/delay.h **** }
 211:/usr/avr/include/util/delay.h **** 
 212:/usr/avr/include/util/delay.h **** /**
 213:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/avr/include/util/delay.h **** 
 215:/usr/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/avr/include/util/delay.h **** 
 217:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/avr/include/util/delay.h **** 
 220:/usr/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/avr/include/util/delay.h **** 
 222:/usr/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/avr/include/util/delay.h **** 
 226:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/avr/include/util/delay.h **** 
 231:/usr/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/avr/include/util/delay.h **** 
 236:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/avr/include/util/delay.h ****    respectively.
 240:/usr/avr/include/util/delay.h **** 
 241:/usr/avr/include/util/delay.h ****    \note
 242:/usr/avr/include/util/delay.h **** 
 243:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/avr/include/util/delay.h **** 
 253:/usr/avr/include/util/delay.h ****  */
 254:/usr/avr/include/util/delay.h **** void
 255:/usr/avr/include/util/delay.h **** _delay_us(double __us)
 333               		.loc 2 255 1 view .LVU59
 334               	.LBB60:
 256:/usr/avr/include/util/delay.h **** {
 257:/usr/avr/include/util/delay.h **** 	double __tmp ;
 335               		.loc 2 257 2 view .LVU60
 258:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 336               		.loc 2 261 2 view .LVU61
 262:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 337               		.loc 2 262 2 view .LVU62
 263:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 338               		.loc 2 263 2 view .LVU63
 264:/usr/avr/include/util/delay.h **** 
 265:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/avr/include/util/delay.h **** 
 268:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/avr/include/util/delay.h **** 
 271:/usr/avr/include/util/delay.h **** 	#else
 272:/usr/avr/include/util/delay.h **** 		//round up by default
 273:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 339               		.loc 2 273 3 view .LVU64
 274:/usr/avr/include/util/delay.h **** 	#endif
 275:/usr/avr/include/util/delay.h **** 
 276:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 340               		.loc 2 276 2 view .LVU65
 341 0054 00EA      		ldi r16,lo8(-96)
 342 0056 0A95      	1:	dec r16
 343 0058 01F4      		brne 1b
 344               	.LVL6:
 345               		.loc 2 276 2 is_stmt 0 view .LVU66
 346               	.LBE60:
 347               	.LBE59:
 113:matrix.c      **** 
 348               		.loc 1 113 9 is_stmt 1 view .LVU67
 349               	.LBB61:
 350               	.LBI61:
 231:matrix.c      **** {
 351               		.loc 1 231 21 view .LVU68
 352               	.LBB62:
 233:matrix.c      ****            (PINC&(1<<6) ? 0 : (1<<1)) |
 353               		.loc 1 233 5 view .LVU69
 233:matrix.c      ****            (PINC&(1<<6) ? 0 : (1<<1)) |
 354               		.loc 1 233 13 is_stmt 0 view .LVU70
 355 005a E6B0      		in r14,0x6
 234:matrix.c      ****            (PINC&(1<<5) ? 0 : (1<<2)) |
 356               		.loc 1 234 13 view .LVU71
 357 005c F6B0      		in r15,0x6
 235:matrix.c      ****            (PINC&(1<<4) ? 0 : (1<<3)) |
 358               		.loc 1 235 13 view .LVU72
 359 005e 16B1      		in r17,0x6
 236:matrix.c      ****            (PINC&(1<<3) ? 0 : (1<<4)) |
 360               		.loc 1 236 13 view .LVU73
 361 0060 26B1      		in r18,0x6
 362 0062 298F      		std Y+25,r18
 237:matrix.c      ****            (PINC&(1<<2) ? 0 : (1<<5)) |
 363               		.loc 1 237 13 view .LVU74
 364 0064 A6B1      		in r26,0x6
 238:matrix.c      ****           //Here is where the inputs stop.
 365               		.loc 1 238 13 view .LVU75
 366 0066 F6B1      		in r31,0x6
 240:matrix.c      ****            (PINC&(1<<0) ? 0 : (1<<7)) |
 367               		.loc 1 240 13 view .LVU76
 368 0068 E6B1      		in r30,0x6
 241:matrix.c      ****            (PINE&(1<<1) ? 0 : (1<<8)) |
 369               		.loc 1 241 13 view .LVU77
 370 006a B6B1      		in r27,0x6
 242:matrix.c      ****            (PINE&(1<<0) ? 0 : (1<<9)) |
 371               		.loc 1 242 13 view .LVU78
 372 006c 7CB1      		in r23,0xc
 243:matrix.c      ****            (PIND&(1<<7) ? 0 : (1<<10)) |
 373               		.loc 1 243 13 view .LVU79
 374 006e 6CB1      		in r22,0xc
 244:matrix.c      ****            (PIND&(1<<6) ? 0 : (1<<11)) |
 375               		.loc 1 244 13 view .LVU80
 376 0070 59B1      		in r21,0x9
 245:matrix.c      ****            (PIND&(1<<5) ? 0 : (1<<12)) |
 377               		.loc 1 245 13 view .LVU81
 378 0072 49B1      		in r20,0x9
 246:matrix.c      ****            (PIND&(1<<4) ? 0 : (1<<13)) |
 379               		.loc 1 246 13 view .LVU82
 380 0074 39B1      		in r19,0x9
 247:matrix.c      ****            (PIND&(1<<3) ? 0 : (1<<14)) |
 381               		.loc 1 247 13 view .LVU83
 382 0076 29B1      		in r18,0x9
 248:matrix.c      ****            (PIND&(1<<2) ? 0 : (1<<15));
 383               		.loc 1 248 13 view .LVU84
 384 0078 99B1      		in r25,0x9
 249:matrix.c      **** }
 385               		.loc 1 249 13 view .LVU85
 386 007a 89B1      		in r24,0x9
 235:matrix.c      ****            (PINC&(1<<4) ? 0 : (1<<3)) |
 387               		.loc 1 235 29 view .LVU86
 388 007c 1295      		swap r17
 389 007e 1695      		lsr r17
 390 0080 1770      		andi r17,lo8(7)
 391 0082 DD24      		clr r13
 392 0084 D394      		inc r13
 393 0086 1D25      		eor r17,r13
 394 0088 10FB      		bst r17,0
 395 008a 6624      		clr r6
 396 008c 60F8      		bld r6,0
 397 008e 712C      		mov r7,__zero_reg__
 398 0090 8301      		movw r16,r6
 399 0092 000F      		lsl r16
 400 0094 111F      		rol r17
 401 0096 000F      		lsl r16
 402 0098 111F      		rol r17
 234:matrix.c      ****            (PINC&(1<<5) ? 0 : (1<<2)) |
 403               		.loc 1 234 29 view .LVU87
 404 009a F694      		lsr r15
 405 009c F694      		lsr r15
 406 009e F694      		lsr r15
 407 00a0 F694      		lsr r15
 408 00a2 F694      		lsr r15
 409 00a4 F694      		lsr r15
 410 00a6 FD24      		eor r15,r13
 411 00a8 F0FA      		bst r15,0
 412 00aa 2224      		clr r2
 413 00ac 20F8      		bld r2,0
 414 00ae 312C      		mov r3,__zero_reg__
 415 00b0 6101      		movw r12,r2
 416 00b2 CC0C      		lsl r12
 417 00b4 DD1C      		rol r13
 234:matrix.c      ****            (PINC&(1<<5) ? 0 : (1<<2)) |
 418               		.loc 1 234 39 view .LVU88
 419 00b6 0C29      		or r16,r12
 420 00b8 1D29      		or r17,r13
 233:matrix.c      ****            (PINC&(1<<6) ? 0 : (1<<1)) |
 421               		.loc 1 233 29 view .LVU89
 422 00ba 0E2C      		mov __tmp_reg__,r14
 423 00bc 000C      		lsl r0
 424 00be FF08      		sbc r15,r15
 425 00c0 E094      		com r14
 426 00c2 F094      		com r15
 427 00c4 EE24      		clr r14
 428 00c6 FF0C      		lsl r15
 429 00c8 EE1C      		rol r14
 430 00ca FF24      		clr r15
 234:matrix.c      ****            (PINC&(1<<5) ? 0 : (1<<2)) |
 431               		.loc 1 234 39 view .LVU90
 432 00cc E02A      		or r14,r16
 433 00ce F12A      		or r15,r17
 236:matrix.c      ****            (PINC&(1<<3) ? 0 : (1<<4)) |
 434               		.loc 1 236 29 view .LVU91
 435 00d0 098D      		ldd r16,Y+25
 436 00d2 0295      		swap r16
 437 00d4 0F70      		andi r16,lo8(15)
 438 00d6 11E0      		ldi r17,lo8(1)
 439 00d8 0127      		eor r16,r17
 440 00da 0170      		andi r16,1
 441 00dc 0983      		std Y+1,r16
 442 00de 1A82      		std Y+2,__zero_reg__
 443 00e0 0981      		ldd r16,Y+1
 444 00e2 1A81      		ldd r17,Y+2
 445 00e4 000F      		lsl r16
 446 00e6 111F      		rol r17
 447 00e8 000F      		lsl r16
 448 00ea 111F      		rol r17
 449 00ec 000F      		lsl r16
 450 00ee 111F      		rol r17
 235:matrix.c      ****            (PINC&(1<<4) ? 0 : (1<<3)) |
 451               		.loc 1 235 39 view .LVU92
 452 00f0 0E29      		or r16,r14
 453 00f2 1F29      		or r17,r15
 237:matrix.c      ****            (PINC&(1<<2) ? 0 : (1<<5)) |
 454               		.loc 1 237 29 view .LVU93
 455 00f4 A695      		lsr r26
 456 00f6 A695      		lsr r26
 457 00f8 A695      		lsr r26
 458 00fa DD24      		clr r13
 459 00fc D394      		inc r13
 460 00fe AD25      		eor r26,r13
 461 0100 A170      		andi r26,1
 462 0102 AB83      		std Y+3,r26
 463 0104 1C82      		std Y+4,__zero_reg__
 464 0106 EB80      		ldd r14,Y+3
 465 0108 FC80      		ldd r15,Y+4
 466 010a A4E0      		ldi r26,4
 467               		1:
 468 010c EE0C      		lsl r14
 469 010e FF1C      		rol r15
 470 0110 AA95      		dec r26
 471 0112 01F4      		brne 1b
 236:matrix.c      ****            (PINC&(1<<3) ? 0 : (1<<4)) |
 472               		.loc 1 236 39 view .LVU94
 473 0114 E02A      		or r14,r16
 474 0116 F12A      		or r15,r17
 238:matrix.c      ****           //Here is where the inputs stop.
 475               		.loc 1 238 29 view .LVU95
 476 0118 F695      		lsr r31
 477 011a F695      		lsr r31
 478 011c FD25      		eor r31,r13
 479 011e F170      		andi r31,1
 480 0120 FD83      		std Y+5,r31
 481 0122 1E82      		std Y+6,__zero_reg__
 482 0124 0D81      		ldd r16,Y+5
 483 0126 1E81      		ldd r17,Y+6
 484 0128 F5E0      		ldi r31,5
 485               		1:
 486 012a 000F      		lsl r16
 487 012c 111F      		rol r17
 488 012e FA95      		dec r31
 489 0130 01F4      		brne 1b
 237:matrix.c      ****            (PINC&(1<<2) ? 0 : (1<<5)) |
 490               		.loc 1 237 39 view .LVU96
 491 0132 0E29      		or r16,r14
 492 0134 1F29      		or r17,r15
 240:matrix.c      ****            (PINC&(1<<0) ? 0 : (1<<7)) |
 493               		.loc 1 240 29 view .LVU97
 494 0136 E695      		lsr r30
 495 0138 ED25      		eor r30,r13
 496 013a E170      		andi r30,1
 497 013c EF83      		std Y+7,r30
 498 013e 1886      		std Y+8,__zero_reg__
 499 0140 EF81      		ldd r30,Y+7
 500 0142 F885      		ldd r31,Y+8
 501 0144 A6E0      		ldi r26,6
 502               		1:
 503 0146 EE0F      		lsl r30
 504 0148 FF1F      		rol r31
 505 014a AA95      		dec r26
 506 014c 01F4      		brne 1b
 238:matrix.c      ****           //Here is where the inputs stop.
 507               		.loc 1 238 39 view .LVU98
 508 014e 0E2B      		or r16,r30
 509 0150 1F2B      		or r17,r31
 241:matrix.c      ****            (PINE&(1<<1) ? 0 : (1<<8)) |
 510               		.loc 1 241 29 view .LVU99
 511 0152 B095      		com r27
 512 0154 B170      		andi r27,1
 513 0156 B987      		std Y+9,r27
 514 0158 1A86      		std Y+10,__zero_reg__
 515 015a E985      		ldd r30,Y+9
 516 015c FA85      		ldd r31,Y+10
 517 015e F695      		lsr r31
 518 0160 FE2F      		mov r31,r30
 519 0162 EE27      		clr r30
 520 0164 F795      		ror r31
 521 0166 E795      		ror r30
 240:matrix.c      ****            (PINC&(1<<0) ? 0 : (1<<7)) |
 522               		.loc 1 240 39 view .LVU100
 523 0168 0E2B      		or r16,r30
 524 016a 1F2B      		or r17,r31
 242:matrix.c      ****            (PINE&(1<<0) ? 0 : (1<<9)) |
 525               		.loc 1 242 29 view .LVU101
 526 016c 7695      		lsr r23
 527 016e 7170      		andi r23,1
 528 0170 7D25      		eor r23,r13
 241:matrix.c      ****            (PINE&(1<<1) ? 0 : (1<<8)) |
 529               		.loc 1 241 39 view .LVU102
 530 0172 172B      		or r17,r23
 243:matrix.c      ****            (PIND&(1<<7) ? 0 : (1<<10)) |
 531               		.loc 1 243 29 view .LVU103
 532 0174 6095      		com r22
 533 0176 6170      		andi r22,1
 534 0178 660F      		lsl r22
 535 017a 6C87      		std Y+12,r22
 536 017c 1B86      		std Y+11,__zero_reg__
 242:matrix.c      ****            (PINE&(1<<0) ? 0 : (1<<9)) |
 537               		.loc 1 242 39 view .LVU104
 538 017e 6B85      		ldd r22,Y+11
 539 0180 7C85      		ldd r23,Y+12
 540 0182 062B      		or r16,r22
 541 0184 172B      		or r17,r23
 244:matrix.c      ****            (PIND&(1<<6) ? 0 : (1<<11)) |
 542               		.loc 1 244 29 view .LVU105
 543 0186 652F      		mov r22,r21
 544 0188 550F      		lsl r21
 545 018a 770B      		sbc r23,r23
 546 018c 6095      		com r22
 547 018e 7095      		com r23
 548 0190 572F      		mov r21,r23
 549 0192 551F      		rol r21
 550 0194 5527      		clr r21
 551 0196 551F      		rol r21
 552 0198 550F      		lsl r21
 553 019a 550F      		lsl r21
 554 019c 5E87      		std Y+14,r21
 555 019e 1D86      		std Y+13,__zero_reg__
 243:matrix.c      ****            (PIND&(1<<7) ? 0 : (1<<10)) |
 556               		.loc 1 243 39 view .LVU106
 557 01a0 ED85      		ldd r30,Y+13
 558 01a2 FE85      		ldd r31,Y+14
 559 01a4 0E2B      		or r16,r30
 560 01a6 1F2B      		or r17,r31
 245:matrix.c      ****            (PIND&(1<<5) ? 0 : (1<<12)) |
 561               		.loc 1 245 29 view .LVU107
 562 01a8 4295      		swap r20
 563 01aa 4695      		lsr r20
 564 01ac 4695      		lsr r20
 565 01ae 4370      		andi r20,lo8(3)
 566 01b0 4D25      		eor r20,r13
 567 01b2 4170      		andi r20,1
 568 01b4 440F      		lsl r20
 569 01b6 440F      		lsl r20
 570 01b8 440F      		lsl r20
 571 01ba 488B      		std Y+16,r20
 572 01bc 1F86      		std Y+15,__zero_reg__
 244:matrix.c      ****            (PIND&(1<<6) ? 0 : (1<<11)) |
 573               		.loc 1 244 40 view .LVU108
 574 01be 4F85      		ldd r20,Y+15
 575 01c0 5889      		ldd r21,Y+16
 576 01c2 042B      		or r16,r20
 577 01c4 152B      		or r17,r21
 246:matrix.c      ****            (PIND&(1<<4) ? 0 : (1<<13)) |
 578               		.loc 1 246 29 view .LVU109
 579 01c6 3295      		swap r19
 580 01c8 3695      		lsr r19
 581 01ca 3770      		andi r19,lo8(7)
 582 01cc 3D25      		eor r19,r13
 583 01ce 3170      		andi r19,1
 584 01d0 3295      		swap r19
 585 01d2 307F      		andi r19,lo8(-16)
 586 01d4 3A8B      		std Y+18,r19
 587 01d6 198A      		std Y+17,__zero_reg__
 245:matrix.c      ****            (PIND&(1<<5) ? 0 : (1<<12)) |
 588               		.loc 1 245 40 view .LVU110
 589 01d8 6989      		ldd r22,Y+17
 590 01da 7A89      		ldd r23,Y+18
 591 01dc 062B      		or r16,r22
 592 01de 172B      		or r17,r23
 247:matrix.c      ****            (PIND&(1<<3) ? 0 : (1<<14)) |
 593               		.loc 1 247 29 view .LVU111
 594 01e0 2295      		swap r18
 595 01e2 2F70      		andi r18,lo8(15)
 596 01e4 2D25      		eor r18,r13
 597 01e6 2170      		andi r18,1
 598 01e8 2295      		swap r18
 599 01ea 220F      		lsl r18
 600 01ec 207E      		andi r18,lo8(-32)
 601 01ee 2C8B      		std Y+20,r18
 602 01f0 1B8A      		std Y+19,__zero_reg__
 246:matrix.c      ****            (PIND&(1<<4) ? 0 : (1<<13)) |
 603               		.loc 1 246 40 view .LVU112
 604 01f2 EB89      		ldd r30,Y+19
 605 01f4 FC89      		ldd r31,Y+20
 606 01f6 0E2B      		or r16,r30
 607 01f8 1F2B      		or r17,r31
 248:matrix.c      ****            (PIND&(1<<2) ? 0 : (1<<15));
 608               		.loc 1 248 29 view .LVU113
 609 01fa 9695      		lsr r25
 610 01fc 9695      		lsr r25
 611 01fe 9695      		lsr r25
 612 0200 9D25      		eor r25,r13
 613 0202 9170      		andi r25,1
 614 0204 9295      		swap r25
 615 0206 990F      		lsl r25
 616 0208 990F      		lsl r25
 617 020a 907C      		andi r25,lo8(-64)
 618 020c 9E8B      		std Y+22,r25
 619 020e 1D8A      		std Y+21,__zero_reg__
 247:matrix.c      ****            (PIND&(1<<3) ? 0 : (1<<14)) |
 620               		.loc 1 247 40 view .LVU114
 621 0210 2D89      		ldd r18,Y+21
 622 0212 3E89      		ldd r19,Y+22
 623 0214 022B      		or r16,r18
 624 0216 132B      		or r17,r19
 249:matrix.c      **** }
 625               		.loc 1 249 29 view .LVU115
 626 0218 8695      		lsr r24
 627 021a 8695      		lsr r24
 628 021c 8D25      		eor r24,r13
 629 021e 8170      		andi r24,1
 630 0220 8795      		ror r24
 631 0222 8827      		clr r24
 632 0224 8795      		ror r24
 633 0226 888F      		std Y+24,r24
 634 0228 1F8A      		std Y+23,__zero_reg__
 248:matrix.c      ****            (PIND&(1<<2) ? 0 : (1<<15));
 635               		.loc 1 248 40 view .LVU116
 636 022a 4F89      		ldd r20,Y+23
 637 022c 588D      		ldd r21,Y+24
 638 022e 042B      		or r16,r20
 639 0230 152B      		or r17,r21
 640               	.LVL7:
 248:matrix.c      ****            (PIND&(1<<2) ? 0 : (1<<15));
 641               		.loc 1 248 40 view .LVU117
 642               	.LBE62:
 643               	.LBE61:
 115:matrix.c      ****             bool prev_bit = matrix_debouncing[row] & ((matrix_row_t)1<<col);
 644               		.loc 1 115 9 is_stmt 1 view .LVU118
 645               	.LBB63:
 115:matrix.c      ****             bool prev_bit = matrix_debouncing[row] & ((matrix_row_t)1<<col);
 646               		.loc 1 115 14 view .LVU119
 115:matrix.c      ****             bool prev_bit = matrix_debouncing[row] & ((matrix_row_t)1<<col);
 647               		.loc 1 115 40 view .LVU120
 648               	.LBB54:
 116:matrix.c      ****             bool curr_bit = rows & (1<<row);
 649               		.loc 1 116 70 is_stmt 0 view .LVU121
 650 0232 4201      		movw r8,r4
 651 0234 0A2C      		mov r0,r10
 652 0236 00C0      		rjmp 2f
 653               		1:
 654 0238 880C      		lsl r8
 655 023a 991C      		rol r9
 656               		2:
 657 023c 0A94      		dec r0
 658 023e 02F4      		brpl 1b
 659 0240 80E0      		ldi r24,lo8(matrix_debouncing)
 660 0242 C82E      		mov r12,r24
 661 0244 80E0      		ldi r24,hi8(matrix_debouncing)
 662 0246 D82E      		mov r13,r24
 663               	.LBE54:
 115:matrix.c      ****             bool prev_bit = matrix_debouncing[row] & ((matrix_row_t)1<<col);
 664               		.loc 1 115 27 view .LVU122
 665 0248 F12C      		mov r15,__zero_reg__
 666 024a E12C      		mov r14,__zero_reg__
 667               	.LVL8:
 668               	.L21:
 669               	.LBB55:
 116:matrix.c      ****             bool curr_bit = rows & (1<<row);
 670               		.loc 1 116 13 is_stmt 1 view .LVU123
 116:matrix.c      ****             bool curr_bit = rows & (1<<row);
 671               		.loc 1 116 46 is_stmt 0 view .LVU124
 672 024c F601      		movw r30,r12
 673 024e 8191      		ld r24,Z+
 674 0250 9191      		ld r25,Z+
 675 0252 6F01      		movw r12,r30
 676               	.LVL9:
 117:matrix.c      ****             if (prev_bit != curr_bit) {
 677               		.loc 1 117 13 is_stmt 1 view .LVU125
 118:matrix.c      ****                 matrix_debouncing[row] ^= ((matrix_row_t)1<<col);
 678               		.loc 1 118 13 view .LVU126
 116:matrix.c      ****             bool curr_bit = rows & (1<<row);
 679               		.loc 1 116 52 is_stmt 0 view .LVU127
 680 0254 9C01      		movw r18,r24
 681 0256 2821      		and r18,r8
 682 0258 3921      		and r19,r9
 116:matrix.c      ****             bool curr_bit = rows & (1<<row);
 683               		.loc 1 116 18 view .LVU128
 684 025a 51E0      		ldi r21,lo8(1)
 685 025c 232B      		or r18,r19
 686 025e 01F4      		brne .L17
 687 0260 50E0      		ldi r21,0
 688               	.L17:
 117:matrix.c      ****             if (prev_bit != curr_bit) {
 689               		.loc 1 117 38 view .LVU129
 690 0262 9201      		movw r18,r4
 691 0264 0E2C      		mov r0,r14
 692 0266 00C0      		rjmp 2f
 693               		1:
 694 0268 220F      		lsl r18
 695 026a 331F      		rol r19
 696               		2:
 697 026c 0A94      		dec r0
 698 026e 02F4      		brpl 1b
 117:matrix.c      ****             if (prev_bit != curr_bit) {
 699               		.loc 1 117 18 view .LVU130
 700 0270 2023      		and r18,r16
 701 0272 3123      		and r19,r17
 702 0274 41E0      		ldi r20,lo8(1)
 703 0276 232B      		or r18,r19
 704 0278 01F4      		brne .L18
 705 027a 40E0      		ldi r20,0
 706               	.L18:
 118:matrix.c      ****                 matrix_debouncing[row] ^= ((matrix_row_t)1<<col);
 707               		.loc 1 118 16 view .LVU131
 708 027c 5417      		cp r21,r20
 709 027e 01F0      		breq .L16
 119:matrix.c      ****                 if (debouncing) {
 710               		.loc 1 119 17 is_stmt 1 view .LVU132
 119:matrix.c      ****                 if (debouncing) {
 711               		.loc 1 119 40 is_stmt 0 view .LVU133
 712 0280 F601      		movw r30,r12
 713 0282 3297      		sbiw r30,2
 714 0284 8825      		eor r24,r8
 715               	.LVL10:
 119:matrix.c      ****                 if (debouncing) {
 716               		.loc 1 119 40 view .LVU134
 717 0286 9925      		eor r25,r9
 718 0288 9183      		std Z+1,r25
 719 028a 8083      		st Z,r24
 720               	.LVL11:
 120:matrix.c      ****                     dprint("bounce!: "); dprintf("%02X", debouncing); dprintln();
 721               		.loc 1 120 17 is_stmt 1 view .LVU135
 120:matrix.c      ****                     dprint("bounce!: "); dprintf("%02X", debouncing); dprintln();
 722               		.loc 1 120 20 is_stmt 0 view .LVU136
 723 028c 8091 0000 		lds r24,debouncing
 724 0290 8823      		tst r24
 725 0292 01F0      		breq .L26
 121:matrix.c      ****                 }
 726               		.loc 1 121 21 is_stmt 1 view .LVU137
 121:matrix.c      ****                 }
 727               		.loc 1 121 21 view .LVU138
 728 0294 8091 0000 		lds r24,debug_config
 729 0298 80FF      		sbrs r24,0
 730 029a 00C0      		rjmp .L26
 121:matrix.c      ****                 }
 731               		.loc 1 121 21 discriminator 1 view .LVU139
 732               	.LBB51:
 121:matrix.c      ****                 }
 733               		.loc 1 121 21 discriminator 1 view .LVU140
 121:matrix.c      ****                 }
 734               		.loc 1 121 21 discriminator 1 view .LVU141
 735               	.LBE51:
 736 029c 80E0      		ldi r24,lo8(__c.8)
 737 029e 90E0      		ldi r25,hi8(__c.8)
 738 02a0 0E94 0000 		call xputs
 739               	.LVL12:
 121:matrix.c      ****                 }
 740               		.loc 1 121 21 discriminator 1 view .LVU142
 121:matrix.c      ****                 }
 741               		.loc 1 121 42 discriminator 1 view .LVU143
 121:matrix.c      ****                 }
 742               		.loc 1 121 42 discriminator 1 view .LVU144
 743 02a4 8091 0000 		lds r24,debug_config
 744 02a8 80FF      		sbrs r24,0
 745 02aa 00C0      		rjmp .L26
 121:matrix.c      ****                 }
 746               		.loc 1 121 42 discriminator 4 view .LVU145
 747               	.LBB52:
 121:matrix.c      ****                 }
 748               		.loc 1 121 42 discriminator 4 view .LVU146
 121:matrix.c      ****                 }
 749               		.loc 1 121 42 discriminator 4 view .LVU147
 750               	.LBE52:
 751 02ac 8091 0000 		lds r24,debouncing
 752 02b0 1F92      		push __zero_reg__
 753 02b2 8F93      		push r24
 754 02b4 20E0      		ldi r18,lo8(__c.7)
 755 02b6 30E0      		ldi r19,hi8(__c.7)
 756 02b8 3F93      		push r19
 757 02ba 2F93      		push r18
 758 02bc 0E94 0000 		call __xprintf
 759               	.LVL13:
 121:matrix.c      ****                 }
 760               		.loc 1 121 42 discriminator 4 view .LVU148
 121:matrix.c      ****                 }
 761               		.loc 1 121 71 discriminator 4 view .LVU149
 121:matrix.c      ****                 }
 762               		.loc 1 121 71 discriminator 4 view .LVU150
 763 02c0 8091 0000 		lds r24,debug_config
 764 02c4 0F90      		pop __tmp_reg__
 765 02c6 0F90      		pop __tmp_reg__
 766 02c8 0F90      		pop __tmp_reg__
 767 02ca 0F90      		pop __tmp_reg__
 768 02cc 80FF      		sbrs r24,0
 769 02ce 00C0      		rjmp .L26
 121:matrix.c      ****                 }
 770               		.loc 1 121 71 discriminator 7 view .LVU151
 771               	.LBB53:
 121:matrix.c      ****                 }
 772               		.loc 1 121 71 discriminator 7 view .LVU152
 121:matrix.c      ****                 }
 773               		.loc 1 121 71 discriminator 7 view .LVU153
 774               	.LBE53:
 775 02d0 80E0      		ldi r24,lo8(__c.6)
 776 02d2 90E0      		ldi r25,hi8(__c.6)
 777 02d4 0E94 0000 		call xputs
 778               	.LVL14:
 779               	.L26:
 121:matrix.c      ****                 }
 780               		.loc 1 121 71 discriminator 9 view .LVU154
 123:matrix.c      ****             }
 781               		.loc 1 123 17 discriminator 9 view .LVU155
 123:matrix.c      ****             }
 782               		.loc 1 123 28 is_stmt 0 discriminator 9 view .LVU156
 783 02d8 5AE0      		ldi r21,lo8(10)
 784 02da 5093 0000 		sts debouncing,r21
 785               	.L16:
 786               	.LBE55:
 115:matrix.c      ****             bool prev_bit = matrix_debouncing[row] & ((matrix_row_t)1<<col);
 787               		.loc 1 115 58 is_stmt 1 discriminator 2 view .LVU157
 788 02de 6FEF      		ldi r22,-1
 789 02e0 E61A      		sub r14,r22
 790 02e2 F60A      		sbc r15,r22
 791               	.LVL15:
 115:matrix.c      ****             bool prev_bit = matrix_debouncing[row] & ((matrix_row_t)1<<col);
 792               		.loc 1 115 40 discriminator 2 view .LVU158
 793 02e4 70E1      		ldi r23,16
 794 02e6 E716      		cp r14,r23
 795 02e8 F104      		cpc r15,__zero_reg__
 796 02ea 01F0      		breq .+2
 797 02ec 00C0      		rjmp .L21
 798               	.LBE63:
 126:matrix.c      ****     }
 799               		.loc 1 126 9 discriminator 2 view .LVU159
 800 02ee 0E94 0000 		call unselect_cols
 801               	.LVL16:
 802               	.LBE48:
 110:matrix.c      ****         select_col(col);
 803               		.loc 1 110 54 discriminator 2 view .LVU160
 110:matrix.c      ****         select_col(col);
 804               		.loc 1 110 36 discriminator 2 view .LVU161
 805 02f2 8FEF      		ldi r24,-1
 806 02f4 A81A      		sub r10,r24
 807 02f6 B80A      		sbc r11,r24
 808               	.LVL17:
 110:matrix.c      ****         select_col(col);
 809               		.loc 1 110 36 is_stmt 0 discriminator 2 view .LVU162
 810 02f8 98E0      		ldi r25,8
 811 02fa A916      		cp r10,r25
 812 02fc B104      		cpc r11,__zero_reg__
 813 02fe 01F0      		breq .+2
 814 0300 00C0      		rjmp .L22
 815               	.LBE66:
 129:matrix.c      ****         if (--debouncing) {
 816               		.loc 1 129 5 is_stmt 1 view .LVU163
 129:matrix.c      ****         if (--debouncing) {
 817               		.loc 1 129 9 is_stmt 0 view .LVU164
 818 0302 8091 0000 		lds r24,debouncing
 129:matrix.c      ****         if (--debouncing) {
 819               		.loc 1 129 8 view .LVU165
 820 0306 8823      		tst r24
 821 0308 01F0      		breq .L25
 130:matrix.c      ****             _delay_ms(1);
 822               		.loc 1 130 9 is_stmt 1 view .LVU166
 130:matrix.c      ****             _delay_ms(1);
 823               		.loc 1 130 13 is_stmt 0 view .LVU167
 824 030a 8150      		subi r24,lo8(-(-1))
 130:matrix.c      ****             _delay_ms(1);
 825               		.loc 1 130 12 view .LVU168
 826 030c 8093 0000 		sts debouncing,r24
 827 0310 8823      		tst r24
 828 0312 01F0      		breq .L24
 131:matrix.c      ****         } else {
 829               		.loc 1 131 13 is_stmt 1 view .LVU169
 830               	.LVL18:
 831               	.LBB67:
 832               	.LBI67:
 166:/usr/avr/include/util/delay.h **** {
 833               		.loc 2 166 1 view .LVU170
 834               	.LBB68:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 835               		.loc 2 168 2 view .LVU171
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 836               		.loc 2 172 2 view .LVU172
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 837               		.loc 2 173 2 view .LVU173
 174:/usr/avr/include/util/delay.h **** 
 838               		.loc 2 174 2 view .LVU174
 184:/usr/avr/include/util/delay.h **** 	#endif
 839               		.loc 2 184 3 view .LVU175
 187:/usr/avr/include/util/delay.h **** 
 840               		.loc 2 187 2 view .LVU176
 841 0314 EFE9      		ldi r30,lo8(3999)
 842 0316 FFE0      		ldi r31,hi8(3999)
 843 0318 3197      	1:	sbiw r30,1
 844 031a 01F4      		brne 1b
 845 031c 00C0      		rjmp .
 846 031e 0000      		nop
 847               	.LVL19:
 848               	.L25:
 187:/usr/avr/include/util/delay.h **** 
 849               		.loc 2 187 2 is_stmt 0 view .LVU177
 850               	.LBE68:
 851               	.LBE67:
 139:matrix.c      **** }
 852               		.loc 1 139 5 is_stmt 1 view .LVU178
 140:matrix.c      **** 
 853               		.loc 1 140 1 is_stmt 0 view .LVU179
 854 0320 81E0      		ldi r24,lo8(1)
 855 0322 90E0      		ldi r25,0
 856               	/* epilogue start */
 857 0324 6996      		adiw r28,25
 858 0326 0FB6      		in __tmp_reg__,__SREG__
 859 0328 F894      		cli
 860 032a DEBF      		out __SP_H__,r29
 861 032c 0FBE      		out __SREG__,__tmp_reg__
 862 032e CDBF      		out __SP_L__,r28
 863 0330 DF91      		pop r29
 864 0332 CF91      		pop r28
 865 0334 1F91      		pop r17
 866 0336 0F91      		pop r16
 867               	.LVL20:
 140:matrix.c      **** 
 868               		.loc 1 140 1 view .LVU180
 869 0338 FF90      		pop r15
 870 033a EF90      		pop r14
 871               	.LVL21:
 140:matrix.c      **** 
 872               		.loc 1 140 1 view .LVU181
 873 033c DF90      		pop r13
 874 033e CF90      		pop r12
 875 0340 BF90      		pop r11
 876 0342 AF90      		pop r10
 877               	.LVL22:
 140:matrix.c      **** 
 878               		.loc 1 140 1 view .LVU182
 879 0344 9F90      		pop r9
 880 0346 8F90      		pop r8
 881 0348 7F90      		pop r7
 882 034a 6F90      		pop r6
 883 034c 5F90      		pop r5
 884 034e 4F90      		pop r4
 885 0350 3F90      		pop r3
 886 0352 2F90      		pop r2
 887 0354 0895      		ret
 888               	.LVL23:
 889               	.L14:
 890               	.LBB69:
 891               	.LBB65:
 892               	.LBB64:
 893               	.LBB58:
 282:matrix.c      ****         case 1:
 283:matrix.c      ****             DDRE  |=  (1<<7);
 894               		.loc 1 283 13 is_stmt 1 view .LVU183
 895               		.loc 1 283 19 is_stmt 0 view .LVU184
 896 0356 6F9A      		sbi 0xd,7
 284:matrix.c      ****             PORTE &= ~(1<<7);
 897               		.loc 1 284 13 is_stmt 1 view .LVU185
 898               		.loc 1 284 19 is_stmt 0 view .LVU186
 899 0358 7798      		cbi 0xe,7
 285:matrix.c      ****             break;
 900               		.loc 1 285 13 is_stmt 1 view .LVU187
 901 035a 00C0      		rjmp .L15
 902               	.L13:
 286:matrix.c      ****         case 2:
 287:matrix.c      ****             DDRE  |=  (1<<6);
 903               		.loc 1 287 13 view .LVU188
 904               		.loc 1 287 19 is_stmt 0 view .LVU189
 905 035c 6E9A      		sbi 0xd,6
 288:matrix.c      ****             PORTE &= ~(1<<6);
 906               		.loc 1 288 13 is_stmt 1 view .LVU190
 907               		.loc 1 288 19 is_stmt 0 view .LVU191
 908 035e 7698      		cbi 0xe,6
 289:matrix.c      ****             break;
 909               		.loc 1 289 13 is_stmt 1 view .LVU192
 910 0360 00C0      		rjmp .L15
 911               	.L12:
 290:matrix.c      ****         case 3:
 291:matrix.c      ****             DDRF  |=  (1<<0);
 912               		.loc 1 291 13 view .LVU193
 913               		.loc 1 291 19 is_stmt 0 view .LVU194
 914 0362 809A      		sbi 0x10,0
 292:matrix.c      ****             PORTF &= ~(1<<0);
 915               		.loc 1 292 13 is_stmt 1 view .LVU195
 916               		.loc 1 292 19 is_stmt 0 view .LVU196
 917 0364 8898      		cbi 0x11,0
 293:matrix.c      ****             break;
 918               		.loc 1 293 13 is_stmt 1 view .LVU197
 919 0366 00C0      		rjmp .L15
 920               	.L11:
 294:matrix.c      ****         case 4:
 295:matrix.c      ****             DDRF  |=  (1<<1);
 921               		.loc 1 295 13 view .LVU198
 922               		.loc 1 295 19 is_stmt 0 view .LVU199
 923 0368 819A      		sbi 0x10,1
 296:matrix.c      ****             PORTF &= ~(1<<1);
 924               		.loc 1 296 13 is_stmt 1 view .LVU200
 925               		.loc 1 296 19 is_stmt 0 view .LVU201
 926 036a 8998      		cbi 0x11,1
 297:matrix.c      ****             break;
 927               		.loc 1 297 13 is_stmt 1 view .LVU202
 928 036c 00C0      		rjmp .L15
 929               	.L10:
 298:matrix.c      ****         case 5:
 299:matrix.c      ****             DDRF  |=  (1<<2);
 930               		.loc 1 299 13 view .LVU203
 931               		.loc 1 299 19 is_stmt 0 view .LVU204
 932 036e 829A      		sbi 0x10,2
 300:matrix.c      ****             PORTF &= ~(1<<2);
 933               		.loc 1 300 13 is_stmt 1 view .LVU205
 934               		.loc 1 300 19 is_stmt 0 view .LVU206
 935 0370 8A98      		cbi 0x11,2
 301:matrix.c      ****             break;
 936               		.loc 1 301 13 is_stmt 1 view .LVU207
 937 0372 00C0      		rjmp .L15
 938               	.L9:
 302:matrix.c      ****         case 6:
 303:matrix.c      ****             DDRF  |=  (1<<3);
 939               		.loc 1 303 13 view .LVU208
 940               		.loc 1 303 19 is_stmt 0 view .LVU209
 941 0374 839A      		sbi 0x10,3
 304:matrix.c      ****             PORTF &= ~(1<<3);
 942               		.loc 1 304 13 is_stmt 1 view .LVU210
 943               		.loc 1 304 19 is_stmt 0 view .LVU211
 944 0376 8B98      		cbi 0x11,3
 305:matrix.c      ****             break;
 945               		.loc 1 305 13 is_stmt 1 view .LVU212
 946 0378 00C0      		rjmp .L15
 947               	.L7:
 306:matrix.c      ****         case 7:
 307:matrix.c      ****             DDRF  |=  (1<<4);
 948               		.loc 1 307 13 view .LVU213
 949               		.loc 1 307 19 is_stmt 0 view .LVU214
 950 037a 849A      		sbi 0x10,4
 308:matrix.c      ****             PORTF &= ~(1<<4);
 951               		.loc 1 308 13 is_stmt 1 view .LVU215
 952               		.loc 1 308 19 is_stmt 0 view .LVU216
 953 037c 8C98      		cbi 0x11,4
 309:matrix.c      ****             break;
 954               		.loc 1 309 13 is_stmt 1 view .LVU217
 955 037e 00C0      		rjmp .L15
 956               	.LVL24:
 957               	.L24:
 958               		.loc 1 309 13 is_stmt 0 view .LVU218
 959               	.LBE58:
 960               	.LBE64:
 961               	.LBE65:
 962               	.LBE69:
 963               	.LBB70:
 134:matrix.c      ****             }
 964               		.loc 1 134 27 view .LVU219
 965 0380 80E2      		ldi r24,lo8(32)
 966 0382 E0E0      		ldi r30,lo8(matrix_debouncing)
 967 0384 F0E0      		ldi r31,hi8(matrix_debouncing)
 968 0386 A0E0      		ldi r26,lo8(matrix)
 969 0388 B0E0      		ldi r27,hi8(matrix)
 970               		0:
 971 038a 0190      		ld r0,Z+
 972 038c 0D92      		st X+,r0
 973 038e 8A95      		dec r24
 974 0390 01F4      		brne 0b
 975 0392 00C0      		rjmp .L25
 976               	.LBE70:
 977               		.cfi_endproc
 978               	.LFE11:
 980               		.section	.text.matrix_is_modified,"ax",@progbits
 981               	.global	matrix_is_modified
 983               	matrix_is_modified:
 984               	.LFB12:
 143:matrix.c      ****     if (debouncing) return false;
 985               		.loc 1 143 1 is_stmt 1 view -0
 986               		.cfi_startproc
 987               	/* prologue: function */
 988               	/* frame size = 0 */
 989               	/* stack size = 0 */
 990               	.L__stack_usage = 0
 144:matrix.c      ****     return true;
 991               		.loc 1 144 5 view .LVU221
 144:matrix.c      ****     return true;
 992               		.loc 1 144 8 is_stmt 0 view .LVU222
 993 0000 81E0      		ldi r24,lo8(1)
 994 0002 9091 0000 		lds r25,debouncing
 995 0006 9111      		cpse r25,__zero_reg__
 996 0008 80E0      		ldi r24,0
 997               	.L45:
 998               	/* epilogue start */
 146:matrix.c      **** 
 999               		.loc 1 146 1 view .LVU223
 1000 000a 0895      		ret
 1001               		.cfi_endproc
 1002               	.LFE12:
 1004               		.section	.text.matrix_is_on,"ax",@progbits
 1005               	.global	matrix_is_on
 1007               	matrix_is_on:
 1008               	.LVL25:
 1009               	.LFB13:
 150:matrix.c      ****     return (matrix[row] & ((matrix_row_t)1<<col));
 1010               		.loc 1 150 1 is_stmt 1 view -0
 1011               		.cfi_startproc
 1012               	/* prologue: function */
 1013               	/* frame size = 0 */
 1014               	/* stack size = 0 */
 1015               	.L__stack_usage = 0
 151:matrix.c      **** }
 1016               		.loc 1 151 5 view .LVU225
 151:matrix.c      **** }
 1017               		.loc 1 151 19 is_stmt 0 view .LVU226
 1018 0000 880F      		lsl r24
 1019 0002 991F      		rol r25
 1020               	.LVL26:
 151:matrix.c      **** }
 1021               		.loc 1 151 19 view .LVU227
 1022 0004 FC01      		movw r30,r24
 1023 0006 E050      		subi r30,lo8(-(matrix))
 1024 0008 F040      		sbci r31,hi8(-(matrix))
 151:matrix.c      **** }
 1025               		.loc 1 151 43 view .LVU228
 1026 000a 21E0      		ldi r18,lo8(1)
 1027 000c 30E0      		ldi r19,0
 1028 000e 00C0      		rjmp 2f
 1029               		1:
 1030 0010 220F      		lsl r18
 1031 0012 331F      		rol r19
 1032               		2:
 1033 0014 6A95      		dec r22
 1034 0016 02F4      		brpl 1b
 151:matrix.c      **** }
 1035               		.loc 1 151 25 view .LVU229
 1036 0018 8081      		ld r24,Z
 1037 001a 9181      		ldd r25,Z+1
 1038 001c 2823      		and r18,r24
 1039 001e 3923      		and r19,r25
 1040 0020 81E0      		ldi r24,lo8(1)
 1041 0022 232B      		or r18,r19
 1042 0024 01F4      		brne .L50
 1043 0026 80E0      		ldi r24,0
 1044               	.L50:
 1045               	/* epilogue start */
 152:matrix.c      **** 
 1046               		.loc 1 152 1 view .LVU230
 1047 0028 0895      		ret
 1048               		.cfi_endproc
 1049               	.LFE13:
 1051               		.section	.text.matrix_get_row,"ax",@progbits
 1052               	.global	matrix_get_row
 1054               	matrix_get_row:
 1055               	.LVL27:
 1056               	.LFB14:
 156:matrix.c      ****     return matrix[row];
 1057               		.loc 1 156 1 is_stmt 1 view -0
 1058               		.cfi_startproc
 1059               	/* prologue: function */
 1060               	/* frame size = 0 */
 1061               	/* stack size = 0 */
 1062               	.L__stack_usage = 0
 157:matrix.c      **** }
 1063               		.loc 1 157 5 view .LVU232
 157:matrix.c      **** }
 1064               		.loc 1 157 18 is_stmt 0 view .LVU233
 1065 0000 FC01      		movw r30,r24
 1066 0002 EE0F      		lsl r30
 1067 0004 FF1F      		rol r31
 1068               	.LVL28:
 157:matrix.c      **** }
 1069               		.loc 1 157 18 view .LVU234
 1070 0006 E050      		subi r30,lo8(-(matrix))
 1071 0008 F040      		sbci r31,hi8(-(matrix))
 158:matrix.c      **** 
 1072               		.loc 1 158 1 view .LVU235
 1073 000a 8081      		ld r24,Z
 1074 000c 9181      		ldd r25,Z+1
 1075               	/* epilogue start */
 1076 000e 0895      		ret
 1077               		.cfi_endproc
 1078               	.LFE14:
 1080               		.section	.text.matrix_print,"ax",@progbits
 1081               	.global	matrix_print
 1083               	matrix_print:
 1084               	.LFB15:
 171:matrix.c      ****     print("\nr/c 01234567\n");
 1085               		.loc 1 171 1 is_stmt 1 view -0
 1086               		.cfi_startproc
 1087 0000 CF92      		push r12
 1088               	.LCFI20:
 1089               		.cfi_def_cfa_offset 3
 1090               		.cfi_offset 12, -2
 1091 0002 DF92      		push r13
 1092               	.LCFI21:
 1093               		.cfi_def_cfa_offset 4
 1094               		.cfi_offset 13, -3
 1095 0004 EF92      		push r14
 1096               	.LCFI22:
 1097               		.cfi_def_cfa_offset 5
 1098               		.cfi_offset 14, -4
 1099 0006 FF92      		push r15
 1100               	.LCFI23:
 1101               		.cfi_def_cfa_offset 6
 1102               		.cfi_offset 15, -5
 1103 0008 0F93      		push r16
 1104               	.LCFI24:
 1105               		.cfi_def_cfa_offset 7
 1106               		.cfi_offset 16, -6
 1107 000a 1F93      		push r17
 1108               	.LCFI25:
 1109               		.cfi_def_cfa_offset 8
 1110               		.cfi_offset 17, -7
 1111 000c CF93      		push r28
 1112               	.LCFI26:
 1113               		.cfi_def_cfa_offset 9
 1114               		.cfi_offset 28, -8
 1115 000e DF93      		push r29
 1116               	.LCFI27:
 1117               		.cfi_def_cfa_offset 10
 1118               		.cfi_offset 29, -9
 1119               	/* prologue: function */
 1120               	/* frame size = 0 */
 1121               	/* stack size = 8 */
 1122               	.L__stack_usage = 8
 172:matrix.c      ****     for (matrix_row_t row = 0; row < matrix_rows(); row++) {
 1123               		.loc 1 172 5 view .LVU237
 1124               	.LBB83:
 172:matrix.c      ****     for (matrix_row_t row = 0; row < matrix_rows(); row++) {
 1125               		.loc 1 172 5 view .LVU238
 172:matrix.c      ****     for (matrix_row_t row = 0; row < matrix_rows(); row++) {
 1126               		.loc 1 172 5 view .LVU239
 1127               	.LBE83:
 1128 0010 80E0      		ldi r24,lo8(__c.5)
 1129 0012 90E0      		ldi r25,hi8(__c.5)
 1130 0014 0E94 0000 		call xputs
 173:matrix.c      ****         phex(row); print(": ");
 1131               		.loc 1 173 5 view .LVU240
 1132               	.LBB84:
 173:matrix.c      ****         phex(row); print(": ");
 1133               		.loc 1 173 10 view .LVU241
 173:matrix.c      ****         phex(row); print(": ");
 1134               		.loc 1 173 36 view .LVU242
 1135               	.LBE84:
 172:matrix.c      ****     for (matrix_row_t row = 0; row < matrix_rows(); row++) {
 1136               		.loc 1 172 5 is_stmt 0 view .LVU243
 1137 0018 00E0      		ldi r16,lo8(matrix)
 1138 001a 10E0      		ldi r17,hi8(matrix)
 1139               	.LBB95:
 173:matrix.c      ****         phex(row); print(": ");
 1140               		.loc 1 173 23 view .LVU244
 1141 001c D0E0      		ldi r29,0
 1142 001e C0E0      		ldi r28,0
 174:matrix.c      ****         pbin_reverse(matrix_get_row(row));
 1143               		.loc 1 174 9 view .LVU245
 1144 0020 80E0      		ldi r24,lo8(__c.4)
 1145 0022 E82E      		mov r14,r24
 1146 0024 80E0      		ldi r24,hi8(__c.4)
 1147 0026 F82E      		mov r15,r24
 175:matrix.c      **** #ifdef MATRIX_HAS_GHOST
 1148               		.loc 1 175 9 view .LVU246
 1149 0028 90E0      		ldi r25,lo8(__c.2)
 1150 002a C92E      		mov r12,r25
 1151 002c 90E0      		ldi r25,hi8(__c.2)
 1152 002e D92E      		mov r13,r25
 1153               	.L57:
 174:matrix.c      ****         pbin_reverse(matrix_get_row(row));
 1154               		.loc 1 174 9 is_stmt 1 view .LVU247
 1155               	.LBB85:
 174:matrix.c      ****         pbin_reverse(matrix_get_row(row));
 1156               		.loc 1 174 9 view .LVU248
 174:matrix.c      ****         pbin_reverse(matrix_get_row(row));
 1157               		.loc 1 174 9 view .LVU249
 1158               	.LBE85:
 1159 0030 DF93      		push r29
 1160               	.LCFI28:
 1161               		.cfi_def_cfa_offset 11
 1162 0032 CF93      		push r28
 1163               	.LCFI29:
 1164               		.cfi_def_cfa_offset 12
 1165 0034 FF92      		push r15
 1166               	.LCFI30:
 1167               		.cfi_def_cfa_offset 13
 1168 0036 EF92      		push r14
 1169               	.LCFI31:
 1170               		.cfi_def_cfa_offset 14
 1171 0038 0E94 0000 		call __xprintf
 174:matrix.c      ****         pbin_reverse(matrix_get_row(row));
 1172               		.loc 1 174 20 view .LVU250
 1173               	.LBB86:
 174:matrix.c      ****         pbin_reverse(matrix_get_row(row));
 1174               		.loc 1 174 20 view .LVU251
 174:matrix.c      ****         pbin_reverse(matrix_get_row(row));
 1175               		.loc 1 174 20 view .LVU252
 1176               	.LBE86:
 1177 003c 80E0      		ldi r24,lo8(__c.3)
 1178 003e 90E0      		ldi r25,hi8(__c.3)
 1179 0040 0E94 0000 		call xputs
 175:matrix.c      **** #ifdef MATRIX_HAS_GHOST
 1180               		.loc 1 175 9 view .LVU253
 1181               	.LBB87:
 1182               	.LBI87:
 155:matrix.c      **** {
 1183               		.loc 1 155 14 view .LVU254
 1184               	.LBB88:
 157:matrix.c      **** }
 1185               		.loc 1 157 5 view .LVU255
 157:matrix.c      **** }
 1186               		.loc 1 157 18 is_stmt 0 view .LVU256
 1187 0044 F801      		movw r30,r16
 1188 0046 8081      		ld r24,Z
 1189 0048 0E5F      		subi r16,-2
 1190 004a 1F4F      		sbci r17,-1
 1191               	.LBE88:
 1192               	.LBE87:
 175:matrix.c      **** #ifdef MATRIX_HAS_GHOST
 1193               		.loc 1 175 9 view .LVU257
 1194 004c 0E94 0000 		call bitrev
 1195               	.LBB89:
 175:matrix.c      **** #ifdef MATRIX_HAS_GHOST
 1196               		.loc 1 175 9 is_stmt 1 view .LVU258
 175:matrix.c      **** #ifdef MATRIX_HAS_GHOST
 1197               		.loc 1 175 9 view .LVU259
 1198               	.LBE89:
 1199 0050 1F92      		push __zero_reg__
 1200               	.LCFI32:
 1201               		.cfi_def_cfa_offset 15
 1202 0052 8F93      		push r24
 1203               	.LCFI33:
 1204               		.cfi_def_cfa_offset 16
 1205 0054 DF92      		push r13
 1206               	.LCFI34:
 1207               		.cfi_def_cfa_offset 17
 1208 0056 CF92      		push r12
 1209               	.LCFI35:
 1210               		.cfi_def_cfa_offset 18
 1211 0058 0E94 0000 		call __xprintf
 177:matrix.c      ****             print(" <ghost");
 1212               		.loc 1 177 9 view .LVU260
 1213               	.LBB90:
 1214               	.LBI90:
 187:matrix.c      **** {
 1215               		.loc 1 187 13 view .LVU261
 1216               	.LBB91:
 190:matrix.c      ****         return false;
 1217               		.loc 1 190 5 view .LVU262
 190:matrix.c      ****         return false;
 1218               		.loc 1 190 17 is_stmt 0 view .LVU263
 1219 005c F801      		movw r30,r16
 1220 005e 3297      		sbiw r30,2
 1221 0060 2081      		ld r18,Z
 1222 0062 3181      		ldd r19,Z+1
 190:matrix.c      ****         return false;
 1223               		.loc 1 190 23 view .LVU264
 1224 0064 C901      		movw r24,r18
 1225 0066 0197      		sbiw r24,1
 190:matrix.c      ****         return false;
 1226               		.loc 1 190 28 view .LVU265
 1227 0068 8223      		and r24,r18
 1228 006a 9323      		and r25,r19
 190:matrix.c      ****         return false;
 1229               		.loc 1 190 8 view .LVU266
 1230 006c 4DB7      		in r20,__SP_L__
 1231 006e 5EB7      		in r21,__SP_H__
 1232 0070 485F      		subi r20,-8
 1233 0072 5F4F      		sbci r21,-1
 1234 0074 0FB6      		in __tmp_reg__,__SREG__
 1235 0076 F894      		cli
 1236 0078 5EBF      		out __SP_H__,r21
 1237 007a 0FBE      		out __SREG__,__tmp_reg__
 1238 007c 4DBF      		out __SP_L__,r20
 1239               	.LCFI36:
 1240               		.cfi_def_cfa_offset 10
 1241 007e 892B      		or r24,r25
 1242 0080 01F0      		breq .L53
 1243 0082 E0E0      		ldi r30,lo8(matrix)
 1244 0084 F0E0      		ldi r31,hi8(matrix)
 1245               	.LBB92:
 194:matrix.c      ****         if (i != row && (matrix[i] & matrix[row]))
 1246               		.loc 1 194 23 view .LVU267
 1247 0086 90E0      		ldi r25,0
 1248 0088 80E0      		ldi r24,0
 1249               	.L56:
 195:matrix.c      ****             return true;
 1250               		.loc 1 195 9 is_stmt 1 view .LVU268
 195:matrix.c      ****             return true;
 1251               		.loc 1 195 12 is_stmt 0 view .LVU269
 1252 008a C817      		cp r28,r24
 1253 008c D907      		cpc r29,r25
 1254 008e 01F0      		breq .L54
 195:matrix.c      ****             return true;
 1255               		.loc 1 195 36 view .LVU270
 1256 0090 4081      		ld r20,Z
 1257 0092 5181      		ldd r21,Z+1
 1258 0094 4223      		and r20,r18
 1259 0096 5323      		and r21,r19
 195:matrix.c      ****             return true;
 1260               		.loc 1 195 22 view .LVU271
 1261 0098 452B      		or r20,r21
 1262 009a 01F4      		brne .L55
 1263               	.L54:
 194:matrix.c      ****         if (i != row && (matrix[i] & matrix[row]))
 1264               		.loc 1 194 46 is_stmt 1 view .LVU272
 1265 009c 0196      		adiw r24,1
 194:matrix.c      ****         if (i != row && (matrix[i] & matrix[row]))
 1266               		.loc 1 194 30 view .LVU273
 1267 009e 3296      		adiw r30,2
 1268 00a0 8031      		cpi r24,16
 1269 00a2 9105      		cpc r25,__zero_reg__
 1270 00a4 01F4      		brne .L56
 1271               	.L53:
 1272               	.LBE92:
 1273               	.LBE91:
 1274               	.LBE90:
 181:matrix.c      ****     }
 1275               		.loc 1 181 9 discriminator 2 view .LVU274
 1276               	.LBB93:
 181:matrix.c      ****     }
 1277               		.loc 1 181 9 discriminator 2 view .LVU275
 181:matrix.c      ****     }
 1278               		.loc 1 181 9 discriminator 2 view .LVU276
 1279               	.LBE93:
 1280 00a6 80E0      		ldi r24,lo8(__c.0)
 1281 00a8 90E0      		ldi r25,hi8(__c.0)
 1282 00aa 0E94 0000 		call xputs
 173:matrix.c      ****         phex(row); print(": ");
 1283               		.loc 1 173 56 discriminator 2 view .LVU277
 1284 00ae 2196      		adiw r28,1
 173:matrix.c      ****         phex(row); print(": ");
 1285               		.loc 1 173 36 discriminator 2 view .LVU278
 1286 00b0 C031      		cpi r28,16
 1287 00b2 D105      		cpc r29,__zero_reg__
 1288 00b4 01F0      		breq .+2
 1289 00b6 00C0      		rjmp .L57
 1290               	/* epilogue start */
 1291               	.LBE95:
 183:matrix.c      **** 
 1292               		.loc 1 183 1 is_stmt 0 view .LVU279
 1293 00b8 DF91      		pop r29
 1294 00ba CF91      		pop r28
 1295 00bc 1F91      		pop r17
 1296 00be 0F91      		pop r16
 1297 00c0 FF90      		pop r15
 1298 00c2 EF90      		pop r14
 1299 00c4 DF90      		pop r13
 1300 00c6 CF90      		pop r12
 1301 00c8 0895      		ret
 1302               	.L55:
 1303               	.LBB96:
 178:matrix.c      ****         }
 1304               		.loc 1 178 13 is_stmt 1 view .LVU280
 1305               	.LBB94:
 178:matrix.c      ****         }
 1306               		.loc 1 178 13 view .LVU281
 178:matrix.c      ****         }
 1307               		.loc 1 178 13 view .LVU282
 1308               	.LBE94:
 1309 00ca 80E0      		ldi r24,lo8(__c.1)
 1310 00cc 90E0      		ldi r25,hi8(__c.1)
 1311 00ce 0E94 0000 		call xputs
 1312 00d2 00C0      		rjmp .L53
 1313               	.LBE96:
 1314               		.cfi_endproc
 1315               	.LFE15:
 1317               		.section	.text.matrix_key_count,"ax",@progbits
 1318               	.global	matrix_key_count
 1320               	matrix_key_count:
 1321               	.LFB17:
 203:matrix.c      ****     matrix_row_t count = 0;
 1322               		.loc 1 203 1 view -0
 1323               		.cfi_startproc
 1324 0000 0F93      		push r16
 1325               	.LCFI37:
 1326               		.cfi_def_cfa_offset 3
 1327               		.cfi_offset 16, -2
 1328 0002 1F93      		push r17
 1329               	.LCFI38:
 1330               		.cfi_def_cfa_offset 4
 1331               		.cfi_offset 17, -3
 1332 0004 CF93      		push r28
 1333               	.LCFI39:
 1334               		.cfi_def_cfa_offset 5
 1335               		.cfi_offset 28, -4
 1336 0006 DF93      		push r29
 1337               	.LCFI40:
 1338               		.cfi_def_cfa_offset 6
 1339               		.cfi_offset 29, -5
 1340 0008 00D0      		rcall .
 1341 000a 00D0      		rcall .
 1342 000c 00D0      		rcall .
 1343               	.LCFI41:
 1344               		.cfi_def_cfa_offset 12
 1345 000e CDB7      		in r28,__SP_L__
 1346 0010 DEB7      		in r29,__SP_H__
 1347               	.LCFI42:
 1348               		.cfi_def_cfa_register 28
 1349               	/* prologue: function */
 1350               	/* frame size = 6 */
 1351               	/* stack size = 10 */
 1352               	.L__stack_usage = 10
 204:matrix.c      ****     for (matrix_row_t i = 0; i < MATRIX_ROWS; i++) {
 1353               		.loc 1 204 5 view .LVU284
 1354               	.LVL29:
 205:matrix.c      ****         count += bitpop32(matrix[i]);
 1355               		.loc 1 205 5 view .LVU285
 1356               	.LBB97:
 205:matrix.c      ****         count += bitpop32(matrix[i]);
 1357               		.loc 1 205 10 view .LVU286
 205:matrix.c      ****         count += bitpop32(matrix[i]);
 1358               		.loc 1 205 32 view .LVU287
 1359 0012 00E0      		ldi r16,lo8(matrix)
 1360 0014 10E0      		ldi r17,hi8(matrix)
 1361               	.LBE97:
 204:matrix.c      ****     for (matrix_row_t i = 0; i < MATRIX_ROWS; i++) {
 1362               		.loc 1 204 18 is_stmt 0 view .LVU288
 1363 0016 1E82      		std Y+6,__zero_reg__
 1364 0018 1D82      		std Y+5,__zero_reg__
 1365               	.LVL30:
 1366               	.L65:
 1367               	.LBB98:
 206:matrix.c      ****     }
 1368               		.loc 1 206 9 is_stmt 1 discriminator 3 view .LVU289
 206:matrix.c      ****     }
 1369               		.loc 1 206 33 is_stmt 0 discriminator 3 view .LVU290
 1370 001a F801      		movw r30,r16
 1371 001c 8191      		ld r24,Z+
 1372 001e 9191      		ld r25,Z+
 1373 0020 8F01      		movw r16,r30
 206:matrix.c      ****     }
 1374               		.loc 1 206 18 discriminator 3 view .LVU291
 1375 0022 9C01      		movw r18,r24
 1376 0024 50E0      		ldi r21,0
 1377 0026 40E0      		ldi r20,0
 1378 0028 2983      		std Y+1,r18
 1379 002a 3A83      		std Y+2,r19
 1380 002c 4B83      		std Y+3,r20
 1381 002e 5C83      		std Y+4,r21
 1382 0030 CA01      		movw r24,r20
 1383 0032 B901      		movw r22,r18
 1384 0034 0E94 0000 		call bitpop32
 1385               	.LVL31:
 206:matrix.c      ****     }
 1386               		.loc 1 206 15 discriminator 3 view .LVU292
 1387 0038 4D81      		ldd r20,Y+5
 1388 003a 5E81      		ldd r21,Y+6
 1389 003c 480F      		add r20,r24
 1390 003e 511D      		adc r21,__zero_reg__
 1391 0040 5E83      		std Y+6,r21
 1392 0042 4D83      		std Y+5,r20
 1393               	.LVL32:
 205:matrix.c      ****         count += bitpop32(matrix[i]);
 1394               		.loc 1 205 48 is_stmt 1 discriminator 3 view .LVU293
 205:matrix.c      ****         count += bitpop32(matrix[i]);
 1395               		.loc 1 205 32 discriminator 3 view .LVU294
 1396 0044 50E0      		ldi r21,hi8(matrix+32)
 1397 0046 0030      		cpi r16,lo8(matrix+32)
 1398 0048 1507      		cpc r17,r21
 1399 004a 01F4      		brne .L65
 1400               	.LBE98:
 208:matrix.c      **** }
 1401               		.loc 1 208 5 view .LVU295
 209:matrix.c      **** 
 1402               		.loc 1 209 1 is_stmt 0 view .LVU296
 1403 004c 8D81      		ldd r24,Y+5
 1404 004e 9E81      		ldd r25,Y+6
 1405               	/* epilogue start */
 1406 0050 2696      		adiw r28,6
 1407 0052 0FB6      		in __tmp_reg__,__SREG__
 1408 0054 F894      		cli
 1409 0056 DEBF      		out __SP_H__,r29
 1410 0058 0FBE      		out __SREG__,__tmp_reg__
 1411 005a CDBF      		out __SP_L__,r28
 1412 005c DF91      		pop r29
 1413 005e CF91      		pop r28
 1414 0060 1F91      		pop r17
 1415 0062 0F91      		pop r16
 1416 0064 0895      		ret
 1417               		.cfi_endproc
 1418               	.LFE17:
 1420               		.section	.progmem.data.__c.0,"a"
 1423               	__c.0:
 1424 0000 0A00      		.string	"\n"
 1425               		.section	.progmem.data.__c.1,"a"
 1428               	__c.1:
 1429 0000 203C 6768 		.string	" <ghost"
 1429      6F73 7400 
 1430               		.section	.progmem.data.__c.2,"a"
 1433               	__c.2:
 1434 0000 2530 3862 		.string	"%08b"
 1434      00
 1435               		.section	.progmem.data.__c.3,"a"
 1438               	__c.3:
 1439 0000 3A20 00   		.string	": "
 1440               		.section	.progmem.data.__c.4,"a"
 1443               	__c.4:
 1444 0000 2530 3258 		.string	"%02X"
 1444      00
 1445               		.section	.progmem.data.__c.5,"a"
 1448               	__c.5:
 1449 0000 0A72 2F63 		.string	"\nr/c 01234567\n"
 1449      2030 3132 
 1449      3334 3536 
 1449      370A 00
 1450               		.section	.progmem.data.__c.6,"a"
 1453               	__c.6:
 1454 0000 0D0A 00   		.string	"\r\n"
 1455               		.section	.progmem.data.__c.7,"a"
 1458               	__c.7:
 1459 0000 2530 3258 		.string	"%02X"
 1459      00
 1460               		.section	.progmem.data.__c.8,"a"
 1463               	__c.8:
 1464 0000 626F 756E 		.string	"bounce!: "
 1464      6365 213A 
 1464      2000 
 1465               		.section	.bss.matrix_debouncing,"aw",@nobits
 1468               	matrix_debouncing:
 1469 0000 0000 0000 		.zero	32
 1469      0000 0000 
 1469      0000 0000 
 1469      0000 0000 
 1469      0000 0000 
 1470               		.section	.bss.matrix,"aw",@nobits
 1473               	matrix:
 1474 0000 0000 0000 		.zero	32
 1474      0000 0000 
 1474      0000 0000 
 1474      0000 0000 
 1474      0000 0000 
 1475               		.section	.data.debouncing,"aw"
 1478               	debouncing:
 1479 0000 0A        		.byte	10
 1480               		.text
 1481               	.Letext0:
 1482               		.file 3 "/usr/avr/include/stdint.h"
 1483               		.file 4 "./tmk_keyboard/tmk_core/common/debug.h"
 1484               		.file 5 "./tmk_keyboard/tmk_core/common/matrix.h"
 1485               		.file 6 "./tmk_keyboard/tmk_core/common/util.h"
 1486               		.file 7 "/usr/avr/include/math.h"
 1487               		.file 8 "./tmk_keyboard/tmk_core/common/avr/xprintf.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
     /tmp/ccl8zRVj.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccl8zRVj.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccl8zRVj.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccl8zRVj.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccl8zRVj.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccl8zRVj.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccl8zRVj.s:13     .text.unselect_cols:0000000000000000 unselect_cols
     /tmp/ccl8zRVj.s:57     .text.matrix_rows:0000000000000000 matrix_rows
     /tmp/ccl8zRVj.s:77     .text.matrix_cols:0000000000000000 matrix_cols
     /tmp/ccl8zRVj.s:96     .text.matrix_init:0000000000000000 matrix_init
     /tmp/ccl8zRVj.s:1473   .bss.matrix:0000000000000000 matrix
     /tmp/ccl8zRVj.s:1468   .bss.matrix_debouncing:0000000000000000 matrix_debouncing
     /tmp/ccl8zRVj.s:177    .text.matrix_scan:0000000000000000 matrix_scan
     /tmp/ccl8zRVj.s:1478   .data.debouncing:0000000000000000 debouncing
     /tmp/ccl8zRVj.s:1463   .progmem.data.__c.8:0000000000000000 __c.8
     /tmp/ccl8zRVj.s:1458   .progmem.data.__c.7:0000000000000000 __c.7
     /tmp/ccl8zRVj.s:1453   .progmem.data.__c.6:0000000000000000 __c.6
     /tmp/ccl8zRVj.s:983    .text.matrix_is_modified:0000000000000000 matrix_is_modified
     /tmp/ccl8zRVj.s:1007   .text.matrix_is_on:0000000000000000 matrix_is_on
     /tmp/ccl8zRVj.s:1054   .text.matrix_get_row:0000000000000000 matrix_get_row
     /tmp/ccl8zRVj.s:1083   .text.matrix_print:0000000000000000 matrix_print
     /tmp/ccl8zRVj.s:1448   .progmem.data.__c.5:0000000000000000 __c.5
     /tmp/ccl8zRVj.s:1443   .progmem.data.__c.4:0000000000000000 __c.4
     /tmp/ccl8zRVj.s:1433   .progmem.data.__c.2:0000000000000000 __c.2
     /tmp/ccl8zRVj.s:1438   .progmem.data.__c.3:0000000000000000 __c.3
     /tmp/ccl8zRVj.s:1423   .progmem.data.__c.0:0000000000000000 __c.0
     /tmp/ccl8zRVj.s:1428   .progmem.data.__c.1:0000000000000000 __c.1
     /tmp/ccl8zRVj.s:1320   .text.matrix_key_count:0000000000000000 matrix_key_count

UNDEFINED SYMBOLS
__tablejump2__
debug_config
xputs
__xprintf
bitrev
bitpop32
__do_copy_data
__do_clear_bss
